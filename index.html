<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<title>Arena Duel â€“ Proto v1</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0b1020">
<style>
  html,body{
    margin:0;
    padding:0;
    height:100%;
    background:#05070b;
    color:#fff;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    -webkit-user-select:none;
    user-select:none;
    overscroll-behavior:none;
  }
  #game{
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    display:block;
    background:#05070b;
    touch-action:none;
    -webkit-tap-highlight-color:transparent;
  }
  .hint{
    position:fixed;
    left:50%;
    bottom:10px;
    transform:translateX(-50%);
    padding:6px 12px;
    border-radius:999px;
    background:rgba(0,0,0,.8);
    border:1px solid rgba(90,120,255,.5);
    font-size:12px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">Suggerimento: aggiungi il gioco alla Home per usarlo come app.</div>
<script>
// ----- costanti logiche -----
const W = 720;
const H = 1280;
const UI_H = 180;
const FIELD_H = H - UI_H;
const LANES_X = [W*0.2, W*0.5, W*0.8];

// canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
let scale=1, offX=0, offY=0;

function resize(){
  const r = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.max(1, Math.round(r.width*dpr));
  canvas.height = Math.max(1, Math.round(r.height*dpr));
  scale = Math.min(canvas.width/W, canvas.height/H);
  offX  = Math.floor((canvas.width  - W*scale)/2);
  offY  = Math.floor((canvas.height - H*scale)/2);
}
window.addEventListener('resize',resize);
window.addEventListener('orientationchange',resize);
resize();

function toLogical(clientX,clientY){
  const r = canvas.getBoundingClientRect();
  const px = (clientX-r.left) * (canvas.width/r.width);
  const py = (clientY-r.top ) * (canvas.height/r.height);
  return {x:(px-offX)/scale, y:(py-offY)/scale};
}
function clamp(v,a,b){return v<a?a:(v>b?b:v);}

// stato
let selectedLane = 1;
const state = {
  running:true,
  time:0,
  manaP:5,
  manaE:5,
  manaMax:10,
  manaRegen:0.02,
  towersP:[],
  towersE:[],
  units:[],
  bullets:[],
  crystal:null,
  result:null,
  wins:0
};

function makeTower(x,y,team){
  return {x,y,team,hp:120,maxHp:120};
}

function resetGame(){
  state.running=true;
  state.time=0;
  state.manaP=5;
  state.manaE=5;
  state.manaMax=10;
  state.towersP=[
    makeTower(W*0.25, FIELD_H-80, 'P'),
    makeTower(W*0.75, FIELD_H-80, 'P')
  ];
  state.towersE=[
    makeTower(W*0.25, 80, 'E'),
    makeTower(W*0.75, 80, 'E')
  ];
  state.units=[];
  state.bullets=[];
  state.crystal={x:W*0.5, y:FIELD_H/2, hp:80, maxHp:80, alive:true};
  state.result=null;
}
resetGame();

// carte
const cards=[
  {key:'scout', name:'Scout', cost:3},
  {key:'spark', name:'Spark', cost:2},
  {key:'tank',  name:'Tank',  cost:4},
  {key:'healer',name:'Healer',cost:3},
  {key:'restart',name:'Riavvia',cost:0}
];
let cardRects=[];
let notEnoughMana=0;

// audio minimale
let ac=null;
function beep(type){
  try{
    ac = ac || new (window.AudioContext||window.webkitAudioContext)();
    const o = ac.createOscillator();
    const g = ac.createGain();
    let f=440,d=0.08;
    if(type==='place'){f=660;d=0.06;}
    if(type==='hit'){f=220;d=0.04;}
    if(type==='win'){f=880;d=0.25;}
    if(type==='lose'){f=160;d=0.25;}
    o.type='square';
    o.frequency.value=f;
    g.gain.value=0.05;
    o.connect(g); g.connect(ac.destination);
    const t=ac.currentTime;
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.0001,t+d);
    o.stop(t+d);
  }catch(e){}
}

function makeUnit(team,lane,kind){
  const x = LANES_X[lane];
  const y = team==='P' ? FIELD_H-130 : 130;
  const dir = team==='P' ? -1 : 1;
  const u={team,lane,kind,x,y,dir,cd:0,hp:40,maxHp:40,atk:10,range:26,speed:60};
  if(kind==='scout'){u.speed=90;u.hp=26;u.maxHp=26;u.atk=9;u.range=24;}
  else if(kind==='tank'){u.speed=40;u.hp=80;u.maxHp=80;u.atk=12;u.range=26;}
  else if(kind==='spark'){u.speed=55;u.hp=30;u.maxHp=30;u.atk=10;u.range=120;}
  else if(kind==='healer'){u.speed=60;u.hp=30;u.maxHp=30;u.atk=-8;u.range=100;}
  return u;
}

function spawnP(kind){
  const card = cards.find(c=>c.key===kind);
  if(!card) return;
  if(kind==='restart'){ resetGame(); return; }
  if(state.manaP < card.cost){ notEnoughMana=0.6; return; }
  state.manaP -= card.cost;
  state.units.push(makeUnit('P',selectedLane,kind));
  beep('place');
}
function spawnE(kind){
  state.units.push(makeUnit('E',Math.floor(Math.random()*3),kind));
}

let aiTimer=2;
function aiStep(dt){
  if(!state.running) return;
  aiTimer-=dt;
  if(aiTimer>0) return;
  aiTimer=1.5+Math.random()*1.5;
  const mana=Math.floor(state.manaE);
  const pool=[];
  if(mana>=2) pool.push('spark');
  if(mana>=3) pool.push('scout','healer');
  if(mana>=4) pool.push('tank');
  if(!pool.length) return;
  const kind=pool[Math.floor(Math.random()*pool.length)];
  const cost=cards.find(c=>c.key===kind).cost;
  state.manaE=Math.max(0,state.manaE-cost);
  spawnE(kind);
}

function update(dt){
  state.time+=dt;
  if(state.running){
    state.manaP = clamp(state.manaP + state.manaRegen*dt*60, 0, state.manaMax);
    state.manaE = clamp(state.manaE + state.manaRegen*dt*60, 0, state.manaMax);
    aiStep(dt);
  }
  notEnoughMana=Math.max(0,notEnoughMana-dt);

  // units
  for(const u of state.units){
    if(!state.running) break;
    u.cd-=dt;
    const enemyTeam = u.team==='P'?'E':'P';
    const foes  = state.units.filter(v=>v.team===enemyTeam && v.lane===u.lane);
    const towers = (enemyTeam==='E'?state.towersE:state.towersP);

    if(u.kind==='healer'){
      let best=null,bestGap=0;
      const allies=state.units.filter(v=>v.team===u.team && v.lane===u.lane);
      for(const a of allies){
        const gap=a.maxHp-a.hp;
        const d=Math.hypot(a.x-u.x,a.y-u.y);
        if(gap>bestGap && d<=u.range){bestGap=gap;best=a;}
      }
      if(!best){
        const allyT = (u.team==='P'?state.towersP:state.towersE);
        for(const t of allyT){
          const gap=t.maxHp-t.hp;
          const d=Math.hypot(t.x-u.x,t.y-u.y);
          if(gap>bestGap && d<=u.range){bestGap=gap;best=t;}
        }
      }
      if(best && u.cd<=0){
        u.cd=0.9;
        best.hp = clamp(best.hp + Math.abs(u.atk),0,best.maxHp);
      }else{
        u.y += u.dir*u.speed*dt;
      }
    }else if(u.kind==='spark'){
      let target=null, bestDist=1e9;
      for(const f of foes){
        const d=Math.hypot(f.x-u.x,f.y-u.y);
        if(d<u.range && d<bestDist){bestDist=d;target=f;}
      }
      if(!target){
        for(const t of towers){
          const d=Math.hypot(t.x-u.x,t.y-u.y);
          if(d<u.range && d<bestDist){bestDist=d;target=t;}
        }
      }
      if(state.crystal && state.crystal.alive && !target){
        const c=state.crystal;
        const d=Math.hypot(c.x-u.x,c.y-u.y);
        if(d<u.range) target=c;
      }
      if(target && u.cd<=0){
        u.cd=0.9;
        state.bullets.push({x:u.x,y:u.y,tx:target.x,ty:target.y,team:u.team,speed:260,dmg:Math.abs(u.atk)});
      }else{
        u.y += u.dir*u.speed*dt;
      }
    }else{
      // melee
      let target=null,bestDist=1e9;
      for(const f of foes){
        const d=Math.hypot(f.x-u.x,f.y-u.y);
        if(d<26 && d<bestDist){bestDist=d;target=f;}
      }
      if(!target){
        for(const t of towers){
          const d=Math.hypot(t.x-u.x,t.y-u.y);
          if(d<30 && d<bestDist){bestDist=d;target=t;}
        }
      }
      if(state.crystal && state.crystal.alive && !target){
        const c=state.crystal;
        const d=Math.hypot(c.x-u.x,c.y-u.y);
        if(d<30) target=c;
      }
      if(target && u.cd<=0){
        u.cd=0.6;
        target.hp -= u.atk;
        beep('hit');
        if(target===state.crystal && target.hp<=0 && target.alive){
          target.alive=false;
          state.manaMax+=4;
          state.manaP=Math.min(state.manaMax,state.manaP+5);
        }
      }else{
        u.y += u.dir*u.speed*dt;
      }
    }
  }
  state.units = state.units.filter(u=>u.hp>0 && u.y>-40 && u.y<FIELD_H+40);

  // bullets
  for(const b of state.bullets){
    const dx=b.tx-b.x, dy=b.ty-b.y;
    const d=Math.hypot(dx,dy)||1;
    const step=b.speed*dt;
    if(step>=d){
      const enemyTeam=b.team==='P'?'E':'P';
      let hit=null;
      for(const u of state.units){
        if(u.team!==enemyTeam) continue;
        const du=Math.hypot(u.x-b.tx,u.y-b.ty);
        if(du<20){hit=u;break;}
      }
      if(!hit){
        const tws = enemyTeam==='E'?state.towersE:state.towersP;
        for(const t of tws){
          const dtw=Math.hypot(t.x-b.tx,t.y-b.ty);
          if(dtw<24){hit=t;break;}
        }
      }
      if(!hit && state.crystal && state.crystal.alive){
        const dc=Math.hypot(state.crystal.x-b.tx,state.crystal.y-b.ty);
        if(dc<24) hit=state.crystal;
      }
      if(hit){
        hit.hp -= b.dmg;
        beep('hit');
        if(hit===state.crystal && hit.hp<=0 && hit.alive){
          hit.alive=false;
          state.manaMax+=4;
          state.manaP=Math.min(state.manaMax,state.manaP+5);
        }
      }
      b._dead=true;
    }else{
      b.x += dx/d*step;
      b.y += dy/d*step;
    }
  }
  state.bullets = state.bullets.filter(b=>!b._dead);

  // vittoria / sconfitta
  function alive(arr){return arr.filter(t=>t.hp>0).length;}
  const pAlive=alive(state.towersP);
  const eAlive=alive(state.towersE);
  if(state.running && (pAlive===0 || eAlive===0)){
    state.running=false;
    if(eAlive===0 && pAlive>0){state.result='win';state.wins++;beep('win');}
    else if(pAlive===0 && eAlive>0){state.result='lose';beep('lose');}
    else state.result='draw';
  }
}

function bg(){
  const g=ctx.createLinearGradient(0,0,0,FIELD_H);
  g.addColorStop(0,'#dfecc2');
  g.addColorStop(1,'#c3dc8e');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,FIELD_H);

  ctx.fillStyle='rgba(0,0,0,0.03)';
  for(let x=0;x<W;x+=80){
    ctx.fillRect(x,0,1,FIELD_H);
  }
  for(let y=0;y<FIELD_H;y+=80){
    ctx.fillRect(0,y,W,1);
  }

  const riverY=FIELD_H/2;
  ctx.fillStyle='#c9a071';
  ctx.fillRect(0,riverY-32,W,12);
  ctx.fillRect(0,riverY+20,W,12);
  const wGrad=ctx.createLinearGradient(0,riverY-20,0,riverY+20);
  wGrad.addColorStop(0,'#b9ecff');
  wGrad.addColorStop(1,'#6bb9e9');
  ctx.fillStyle=wGrad;
  ctx.fillRect(0,riverY-20,W,40);

  ctx.fillStyle='rgba(0,0,0,0.05)';
  const laneX=LANES_X[selectedLane];
  ctx.fillRect(laneX-W*0.17,0,W*0.34,FIELD_H);
}

function hpBar(x,y,w,h,ratio){
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillRect(x,y,w,h);
  const g=ctx.createLinearGradient(x,0,x+w,0);
  g.addColorStop(0,'#7af07a');
  g.addColorStop(1,'#2ec14b');
  ctx.fillStyle=g;
  ctx.fillRect(x,y,w*ratio,h);
}

function drawTower(t){
  const friendly=t.team==='P';
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(t.x,t.y+10,20,8,0,0,Math.PI*2);
  ctx.fill();

  const body=ctx.createLinearGradient(t.x-20,t.y-26,t.x+20,t.y+26);
  body.addColorStop(0,'#f5f7fb');
  body.addColorStop(1,'#b5c2d4');
  ctx.fillStyle=body;
  ctx.beginPath();
  ctx.ellipse(t.x,t.y,26,24,0,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle='#7b889b';
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.ellipse(t.x,t.y,26,24,0,0,Math.PI*2);
  ctx.stroke();

  const head=ctx.createRadialGradient(t.x-4,t.y-4,2,t.x,t.y,14);
  head.addColorStop(0,'#fff');
  head.addColorStop(1,friendly?'#2d7fe8':'#e24c4c');
  ctx.fillStyle=head;
  ctx.beginPath();
  ctx.arc(t.x,t.y,16,0,Math.PI*2);
  ctx.fill();

  hpBar(t.x-24,t.y-32,48,5,clamp(t.hp/t.maxHp,0,1));
}

function drawCrystal(){
  const c=state.crystal;
  if(!c || !c.alive) return;
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(c.x,c.y+20,20,8,0,0,Math.PI*2);
  ctx.fill();
  const grad=ctx.createLinearGradient(c.x-20,c.y-30,c.x+20,c.y+30);
  grad.addColorStop(0,'#8ef5ff');
  grad.addColorStop(0.5,'#5cc2ff');
  grad.addColorStop(1,'#2b7fe6');
  ctx.fillStyle=grad;
  ctx.strokeStyle='#ffffffaa';
  ctx.beginPath();
  ctx.moveTo(c.x,c.y-30);
  ctx.lineTo(c.x+20,c.y);
  ctx.lineTo(c.x,c.y+30);
  ctx.lineTo(c.x-20,c.y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  hpBar(c.x-30,c.y+34,60,5,clamp(c.hp/c.maxHp,0,1));
}

function drawUnit(u){
  const friendly=u.team==='P';
  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(u.x,u.y+10,16,6,0,0,Math.PI*2);
  ctx.fill();

  const body=ctx.createLinearGradient(u.x-10,u.y,u.x+10,u.y+24);
  if(u.kind==='tank'){body.addColorStop(0,friendly?'#8fb4ff':'#ff8f8f');body.addColorStop(1,friendly?'#375bb3':'#b33434');}
  else if(u.kind==='scout'){body.addColorStop(0,friendly?'#9fe3ff':'#ffd39f');body.addColorStop(1,friendly?'#1d9fe0':'#e68a2e');}
  else if(u.kind==='spark'){body.addColorStop(0,'#ffe6a3');body.addColorStop(1,friendly?'#f1b02d':'#e2682e');}
  else{body.addColorStop(0,'#bff5c6');body.addColorStop(1,'#45b663');}
  ctx.fillStyle=body;
  ctx.strokeStyle='#333';
  ctx.beginPath();
  ctx.rect(u.x-12,u.y-4,24,24);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle='#f7d6b0';
  ctx.beginPath();
  ctx.arc(u.x,u.y-10,8,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle='#c6956a';
  ctx.stroke();

  ctx.fillStyle='#000';
  ctx.beginPath();
  ctx.arc(u.x-3,u.y-11,1.2,0,Math.PI*2);
  ctx.arc(u.x+3,u.y-11,1.2,0,Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(u.x,u.y-8,3,0,Math.PI);
  ctx.stroke();

  if(u.kind==='spark'){
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.moveTo(u.x,u.y+4);
    ctx.lineTo(u.x-4,u.y+10);
    ctx.lineTo(u.x+4,u.y+10);
    ctx.closePath();
    ctx.fill();
  }else if(u.kind==='healer'){
    ctx.fillStyle='#fff';
    ctx.fillRect(u.x-2,u.y+2,4,8);
    ctx.fillRect(u.x-6,u.y+4,12,4);
  }else if(u.kind==='tank'){
    ctx.fillStyle='rgba(0,0,0,0.3)';
    ctx.fillRect(u.x-12,u.y+6,24,6);
  }

  hpBar(u.x-14,u.y-22,28,4,clamp(u.hp/u.maxHp,0,1));
}

function drawBullets(){
  for(const b of state.bullets){
    const grad=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,6);
    grad.addColorStop(0,'#fff9c4');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(b.x,b.y,6,0,Math.PI*2);
    ctx.fill();
  }
}

function drawHud(){
  ctx.fillStyle='rgba(0,0,0,0.75)';
  ctx.fillRect(0,0,W,24);
  ctx.fillStyle='#ffd966';
  ctx.font='12px system-ui';
  ctx.textAlign='left';
  ctx.fillText('ðŸ‘‘ '+state.wins,8,16);
  ctx.textAlign='center';
  ctx.fillStyle='#e5f0ff';
  ctx.fillText('In partita: tocca il campo per scegliere corsia, poi le carte.', W/2,16);
}

function drawUI(){
  const y0=FIELD_H;
  ctx.fillStyle='#05070b';
  ctx.fillRect(0,y0,W,UI_H);

  const mx=10,my=y0+8,mw=W-20,mh=12;
  ctx.fillStyle='#222738';
  ctx.fillRect(mx,my,mw,mh);
  const r=clamp(state.manaP/state.manaMax,0,1);
  const g=ctx.createLinearGradient(mx,0,mx+mw,0);
  g.addColorStop(0,'#55d2ff');
  g.addColorStop(1,'#1a7bff');
  ctx.fillStyle=g;
  ctx.fillRect(mx,my,mw*r,mh);
  ctx.fillStyle='#aab7ff';
  ctx.font='11px system-ui';
  ctx.textAlign='left';
  ctx.fillText('Mana: '+Math.floor(state.manaP)+' / '+state.manaMax, mx, my+mh+12);

  const pad=6;
  const cardW=(W-pad*6)/5;
  const cardH=70;
  cardRects=[];
  for(let i=0;i<cards.length;i++){
    const c=cards[i];
    const x=pad + i*(cardW+pad);
    const y=y0+30;
    cardRects.push({x,y,w:cardW,h:cardH,index:i});
    const playable = (c.key==='restart') || (state.manaP>=c.cost && state.running);
    ctx.fillStyle = playable ? '#121826' : '#25293a';
    ctx.strokeStyle = playable ? '#4e6bff' : '#44495f';
    ctx.beginPath();
    ctx.rect(x,y,cardW,cardH);
    ctx.fill();
    ctx.stroke();

    ctx.save();
    ctx.translate(x+cardW/2,y+22);
    if(c.key==='scout'){
      ctx.fillStyle='#7ecbff';
      ctx.beginPath();ctx.arc(0,0,7,0,Math.PI*2);ctx.fill();
    }else if(c.key==='spark'){
      ctx.fillStyle='#ffe58a';
      ctx.beginPath();ctx.moveTo(0,-8);ctx.lineTo(9,8);ctx.lineTo(-9,8);ctx.closePath();ctx.fill();
    }else if(c.key==='tank'){
      ctx.fillStyle='#ff9f88';
      ctx.fillRect(-9,-6,18,12);
    }else if(c.key==='healer'){
      ctx.fillStyle='#7cf0a3';
      ctx.fillRect(-2,-8,4,16);
      ctx.fillRect(-8,-2,16,4);
    }else{
      ctx.strokeStyle='#b7c4ff';
      ctx.beginPath();ctx.arc(0,0,8,Math.PI*0.2,Math.PI*1.8);ctx.stroke();
    }
    ctx.restore();

    ctx.textAlign='center';
    ctx.fillStyle='#e5e9ff';
    ctx.font='11px system-ui';
    ctx.fillText(c.name,x+cardW/2,y+cardH-16);
    if(c.cost>0){
      ctx.fillStyle='#8bb0ff';
      ctx.font='10px system-ui';
      ctx.fillText(c.cost,x+cardW/2,y+14);
    }
  }

  if(notEnoughMana>0){
    ctx.save();
    ctx.globalAlpha=Math.min(1,notEnoughMana/0.6);
    ctx.fillStyle='rgba(0,0,0,0.85)';
    ctx.fillRect(W/2-80,y0+UI_H/2-18,160,36);
    ctx.fillStyle='#ffb3b3';
    ctx.textAlign='center';
    ctx.font='13px system-ui';
    ctx.fillText('Mana insufficiente', W/2, y0+UI_H/2+4);
    ctx.restore();
  }
}

function drawResult(){
  if(!state.result) return;
  ctx.fillStyle='rgba(0,0,0,0.7)';
  ctx.fillRect(0,FIELD_H/2-50,W,100);
  ctx.fillStyle='#fff';
  ctx.textAlign='center';
  ctx.font='24px system-ui';
  const t = state.result==='win'?'Vittoria!':(state.result==='lose'?'Sconfitta':'Pareggio');
  ctx.fillText(t,W/2,FIELD_H/2-8);
  ctx.font='14px system-ui';
  ctx.fillStyle='#d7e0ff';
  ctx.fillText("Tocca 'Riavvia' per giocare di nuovo.",W/2,FIELD_H/2+18);
}

// loop
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000);
  last=now;
  update(dt);
  ctx.setTransform(scale,0,0,scale,offX,offY);
  ctx.clearRect(0,0,W,H);
  bg();
  for(const t of state.towersE) drawTower(t);
  for(const t of state.towersP) drawTower(t);
  drawCrystal();
  for(const u of state.units) drawUnit(u);
  drawBullets();
  drawHud();
  drawUI();
  drawResult();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// input
function onPointer(ev){
  ev.preventDefault();
  const p = ('touches' in ev && ev.touches.length)
    ? toLogical(ev.touches[0].clientX,ev.touches[0].clientY)
    : toLogical(ev.clientX,ev.clientY);
  const x=p.x,y=p.y;
  if(x<0||x>W||y<0||y>H) return;
  if(y>FIELD_H){
    for(const r of cardRects){
      if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
        const c=cards[r.index];
        if(c.key==='restart') resetGame();
        else spawnP(c.key);
        return;
      }
    }
  }else{
    let best=0,bd=1e9;
    for(let i=0;i<LANES_X.length;i++){
      const d=Math.abs(LANES_X[i]-x);
      if(d<bd){bd=d;best=i;}
    }
    selectedLane=best;
  }
}
canvas.addEventListener('mousedown',onPointer);
canvas.addEventListener('touchstart',onPointer,{passive:false});

// PWA
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('./sw.js').catch(()=>{});
}
</script>
</body>
</html>
