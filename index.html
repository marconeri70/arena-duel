<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Arena Vertical ‚Äì v3 (real look + proiettili + torri che sparano)</title>
<style>
  html,body{margin:0;height:100%;background:#0f1115;}
  canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block; touch-action:none; -webkit-tap-highlight-color:transparent;}
  .hint{position:fixed;left:0;right:0;top:0;color:#9ec9ff;font:600 14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;text-align:center;pointer-events:none;margin-top:6px;text-shadow:0 1px 2px rgba(0,0,0,.5)}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">Tocca il campo per scegliere la corsia ‚Ä¢ Tocca una carta per piazzare l'unit√†</div>
<script>
/* ================= Canvas & mapping (portrait) ================= */
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d',{alpha:false});
const W=720,H=1280,UI_H=200,FIELD_H=H-UI_H;
let scale=1,offX=0,offY=0;
function resize(){
  const r=canvas.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  canvas.width = Math.max(1, Math.round(r.width*dpr));
  canvas.height= Math.max(1, Math.round(r.height*dpr));
  scale = Math.min(canvas.width/W, canvas.height/H);
  offX  = Math.floor((canvas.width - W*scale)/2);
  offY  = Math.floor((canvas.height- H*scale)/2);
}
addEventListener('resize',resize); addEventListener('orientationchange',resize); resize();
function toLogical(ev){
  const r=canvas.getBoundingClientRect();
  const X=(ev.clientX-r.left)*(canvas.width/r.width);
  const Y=(ev.clientY-r.top )*(canvas.height/r.height);
  return {x:(X-offX)/scale, y:(Y-offY)/scale};
}

/* ================= Helpers & textures (v3 visuals) ================= */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

let tex={grass:null,dirt:null};
function makePattern(fillFn,w=128,h=128){
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const g=c.getContext('2d'); fillFn(g,w,h); return g.createPattern(c,'repeat');
}
function buildTextures(){
  // Erba
  tex.grass = makePattern((g,w,h)=>{
    const grd=g.createLinearGradient(0,0,0,h);
    grd.addColorStop(0,'#eae3b4'); grd.addColorStop(1,'#d7cd91');
    g.fillStyle=grd; g.fillRect(0,0,w,h);
    for(let i=0;i<900;i++){
      const a=0.04+Math.random()*0.05; g.fillStyle=`rgba(90,80,40,${a})`;
      g.fillRect(Math.random()*w,Math.random()*h,1,1);
    }
  });
  // Sabbia sponda
  tex.dirt = makePattern((g,w,h)=>{
    g.fillStyle='#cfae7a'; g.fillRect(0,0,w,h);
    for(let i=0;i<600;i++){
      g.fillStyle=`rgba(90,50,30,${0.05+Math.random()*0.07})`;
      g.beginPath(); g.arc(Math.random()*w,Math.random()*h,Math.random()*1.2,0,Math.PI*2); g.fill();
    }
  });
}
buildTextures();

function softShadow(x,y,rx,ry,alpha=0.22){
  ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#000';
  ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fill(); ctx.restore();
}

/* ================== Stato di gioco ================== */
const COL_X=[W*0.18, W*0.5, W*0.82];
const RIVER_Y=FIELD_H*0.5;
let selectedCol=1, last=performance.now(), notEnoughManaBlink=0;

const state={
  manaP:5, manaE:5, manaMax:10, manaRegen:0.016,
  time:0, playing:true,
  match:{t:0,len:120},
  crowns:{you:0, enemy:0},
  playerTowers:[
    {x:W*0.25,y:FIELD_H-95,hp:100,max:100, range:150, rate:1.0, cd:0, muzzle:{x:10,y:-18}},
    {x:W*0.75,y:FIELD_H-95,hp:100,max:100, range:150, rate:1.0, cd:0, muzzle:{x:10,y:-18}}
  ],
  enemyTowers:[
    {x:W*0.25,y:95,hp:100,max:100, range:150, rate:1.0, cd:0, muzzle:{x:10,y:-18}},
    {x:W*0.75,y:95,hp:100,max:100, range:150, rate:1.0, cd:0, muzzle:{x:10,y:-18}}
  ],
  units:[], floats:[], particles:[], projectiles:[]
};

/* ================== SFX minimi ================== */
let ac;
function sfx(kind){ try{
  ac=ac||new (window.AudioContext||window.webkitAudioContext)();
  const o=ac.createOscillator(), g=ac.createGain();
  const map={hit:[220,.05,'square'], place:[660,.06,'square'], win:[880,.35,'triangle'], lose:[160,.35,'triangle'], heal:[520,.07,'sine'], shoot:[780,.05,'triangle'], t_shoot:[520,.06,'square']};
  const [f,t,w]=(map[kind]||[440,.08,'square']); o.type=w; o.frequency.value=f; g.gain.value=.06;
  o.connect(g); g.connect(ac.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+t); o.stop(ac.currentTime+t);
}catch{} }

/* ================== Utility effetti ================== */
function addFloat(x,y,v,c){ state.floats.push({x,y,v,c,t:0}); }
function addHit(x,y,c){ for(let i=0;i<8;i++) state.particles.push({x,y,vx:rand(-1,1),vy:rand(-1.2,-.2),life:rand(.25,.5),t:0,c}); }
function damage(t,d){ if(!('hp'in t))return; t.hp-=d; const c=d>=0?'#ffb36a':'#6afc86'; addFloat(t.x,t.y-24,(d>=0?'-':'+')+Math.abs(d),c); addHit(t.x,t.y-6,c); sfx(d>=0?'hit':'heal'); }
function heal(t,a){ if(!('hp'in t))return; const b=t.hp; t.hp=Math.min(t.max,t.hp+a); if(t.hp>b){ addFloat(t.x,t.y-24,'+'+Math.round(t.hp-b),'#6afc86'); sfx('heal'); }}

/* ================== Unit√† & Proiettili ================== */
function addUnit(team,col,type){
  const x=COL_X[col], y=(team==='P')?FIELD_H-140:140, dir=(team==='P')?-1:1;
  const u={team,x,y,dir,col,type,cd:0,maxhp:1,hp:1,spd:1,atk:1,range:24,rate:1};
  if(type==='scout') Object.assign(u,{spd:1.2,hp:16,maxhp:16,atk:3,range:22,rate:.5});
  else if(type==='tank') Object.assign(u,{spd:.7,hp:60,maxhp:60,atk:6,range:26,rate:1.0});
  else if(type==='spark') Object.assign(u,{spd:.9,hp:12,maxhp:12,atk:8,range:120,rate:0.9});
  else if(type==='healer') Object.assign(u,{spd:1.0,hp:18,maxhp:18,atk:-6,range:90,rate:1.0});
  state.units.push(u); sfx('place');
}
function fireProjectile({x,y}, target, opts){
  const dx=target.x - x, dy=target.y - y, L=Math.hypot(dx,dy)||1;
  const vx = (dx/L) * (opts.speed||420);
  const vy = (dy/L) * (opts.speed||420);
  state.projectiles.push({
    x, y, vx, vy, team:opts.team, heal:opts.heal||false, dmg:opts.dmg||8, life:1.5,
    colorA:opts.colorA||'#fffacd', colorB:opts.colorB||'#7fb6ff', from:opts.kind||'unit'
  });
  sfx(opts.kind==='tower' ? 't_shoot' : 'shoot');
}

/* ================== IA ================== */
let aiT=2.1;
function ai(dt){
  aiT-=dt;
  if(aiT<=0 && state.playing){
    aiT=rand(1.3,2.5);
    const m=Math.floor(state.manaE), pool=[];
    if(m>=2) pool.push('spark'); if(m>=3) pool.push('scout','healer'); if(m>=4) pool.push('tank');
    if(pool.length){
      const tp=pool[(Math.random()*pool.length)|0];
      const cost=tp==='tank'?4:(tp==='scout'||tp==='healer'?3:2);
      state.manaE=Math.max(0, state.manaE-cost);
      addUnit('E', (Math.random()*3)|0, tp);
    }
  }
}

/* ================== Update ================== */
function nearest(u,towers,foes){
  let best=null,score=1e9;
  for(const f of foes){ const s=Math.abs(f.y*u.dir-u.y*u.dir)+Math.abs(f.x-u.x)*.25; if(s<score){score=s;best=f;} }
  if(!best){ let tg=null,sm=1e9; for(const t of towers){ const s=Math.abs(t.y-u.y)+Math.abs(t.x-u.x)*.3; if(t.hp>0 && s<sm){sm=s; tg=t;} } best=tg; }
  return {t:best, dist:best?Math.hypot(best.x-u.x,best.y-u.y):1e9};
}
function towerAI(dt){
  // Torri giocatore
  for(const tw of state.playerTowers){
    tw.cd -= dt;
    if(tw.hp<=0) continue;
    let target=null, best=1e9;
    for(const u of state.units.filter(u=>u.team==='E')){
      if(u.y >= tw.y) continue;
      const d=Math.hypot(u.x-tw.x, u.y-tw.y);
      if(d<tw.range && d<best){ best=d; target=u; }
    }
    if(target && tw.cd<=0){
      tw.cd=tw.rate;
      const mx=tw.x + (tw.muzzle?.x||0);
      const my=tw.y + (tw.muzzle?.y||0);
      fireProjectile({x:mx,y:my}, target, {
        team:'P', heal:false, dmg:7, speed:540, colorA:'#a8c9ff', colorB:'#7fb6ff', kind:'tower'
      });
      addHit(mx,my,'#9ec9ff');
    }
  }
  // Torri nemiche
  for(const tw of state.enemyTowers){
    tw.cd -= dt;
    if(tw.hp<=0) continue;
    let target=null, best=1e9;
    for(const u of state.units.filter(u=>u.team==='P')){
      if(u.y <= tw.y) continue;
      const d=Math.hypot(u.x-tw.x, u.y-tw.y);
      if(d<tw.range && d<best){ best=d; target=u; }
    }
    if(target && tw.cd<=0){
      tw.cd=tw.rate;
      const mx=tw.x + (tw.muzzle?.x||0);
      const my=tw.y + (tw.muzzle?.y||0);
      fireProjectile({x:mx,y:my}, target, {
        team:'E', heal:false, dmg:7, speed:540, colorA:'#ffc1c1', colorB:'#ff9b9b', kind:'tower'
      });
      addHit(mx,my,'#ffc1c1');
    }
  }
}
function step(dt){
  if(state.playing){
    state.match.t+=dt; state.time+=dt;
    if(state.match.t>=state.match.len){ state.playing=false; sfx('lose'); }
    state.manaP = clamp(state.manaP + state.manaRegen*60*dt, 0, state.manaMax);
    state.manaE = clamp(state.manaE + state.manaRegen*60*dt, 0, state.manaMax);
    ai(dt);
    towerAI(dt);
  }
  // Unit√†
  for(const u of state.units){
    const enemy = u.team==='P' ? 'E' : 'P';
    const foes  = state.units.filter(x=>x.team===enemy && x.col===u.col);
    const towers= (enemy==='E'?state.enemyTowers:state.playerTowers).filter(t=>Math.abs(t.x-u.x)<W*0.35);
    const allies= state.units.filter(x=>x.team===u.team && x.col===u.col);
    const allyT = (u.team==='P'?state.playerTowers:state.enemyTowers).filter(t=>Math.abs(t.x-u.x)<W*0.35);
    u.cd-=dt;

    if(u.type==='healer'){
      let tgt=null, bestGap=0;
      for(const a of allies){
        const gap=a.maxhp-a.hp, d=Math.hypot(a.x-u.x,a.y-u.y);
        if(gap>bestGap && d<=u.range){ bestGap=gap; tgt=a; }
      }
      for(const t of allyT){
        const gap=t.max-t.hp, d=Math.hypot(t.x-u.x,t.y-u.y);
        if(gap>bestGap && d<=u.range){ bestGap=gap; tgt=t; }
      }
      if(tgt && u.cd<=0){
        u.cd=u.rate;
        fireProjectile(u, tgt, {team:u.team, heal:true, dmg:Math.abs(u.atk), speed:360, colorA:'#a8f5b0', colorB:'#2bd96a'});
      }else{
        u.y += u.spd * u.dir * 60 * dt;
      }
    } else if(u.type==='spark'){
      const {t,dist}=nearest(u,towers,foes);
      if(t && dist<=u.range){
        if(u.cd<=0){
          u.cd=u.rate;
          fireProjectile(u, t, {team:u.team, heal:false, dmg:u.atk, speed:520, colorA:'#fffacd', colorB:(u.team==='P')?'#7fb6ff':'#ff9b9b'});
        }
      } else {
        u.y += u.spd * u.dir * 60 * dt;
      }
    } else {
      const {t,dist}=nearest(u,towers,foes);
      if(t && dist<=u.range){ if(u.cd<=0){u.cd=u.rate; damage(t,u.atk);} }
      else u.y += u.spd * u.dir * 60 * dt;
    }
  }
  // Proiettili
  for(const p of state.projectiles){
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    const enemyTeam = p.team==='P' ? 'E' : 'P';
    let hitTarget=null;
    for(const u of state.units){
      if((p.heal && u.team!==p.team) || (!p.heal && u.team===p.team)) continue;
      const d=Math.hypot(u.x-p.x,u.y-p.y);
      if(d<14){ hitTarget=u; break; }
    }
    if(!hitTarget){
      const towers = p.heal ? (p.team==='P'?state.playerTowers:state.enemyTowers)
                            : (p.team==='P'?state.enemyTowers:state.playerTowers);
      for(const t of towers){
        const d=Math.hypot(t.x-p.x,t.y-p.y);
        if(d<22){ hitTarget=t; break; }
      }
    }
    if(hitTarget){
      if(p.heal) heal(hitTarget, p.dmg);
      else damage(hitTarget, p.dmg);
      p.life=0;
    }
  }
  state.projectiles = state.projectiles.filter(p=>p.life>0 && p.x>-20 && p.x<W+20 && p.y>-20 && p.y<FIELD_H+20);

  // Pulizia ed esiti
  state.units = state.units.filter(u=>u.hp>0 && u.y>40 && u.y<FIELD_H-40);
  for(const f of state.floats){ f.t+=dt; f.y-=24*dt; } state.floats=state.floats.filter(f=>f.t<.9);
  for(const p of state.particles){ p.t+=dt; p.x+=p.vx*60*dt; p.y+=p.vy*60*dt; p.vy+=.04; } state.particles=state.particles.filter(p=>p.t<p.life);
  const pAlive=state.playerTowers.filter(t=>t.hp>0).length;
  const eAlive=state.enemyTowers.filter(t=>t.hp>0).length;
  state.crowns.you   = 2 - eAlive;
  state.crowns.enemy = 2 - pAlive;
  if(state.playing && (pAlive===0 || eAlive===0)){ state.playing=false; sfx(eAlive===0?'win':'lose'); }
}

/* ================== Rendering (real look) ================== */
function bg(){
  ctx.fillStyle=tex.grass; ctx.fillRect(0,0,W,FIELD_H);
  const vg=ctx.createRadialGradient(W/2,FIELD_H/2,Math.min(W,FIELD_H)*0.2, W/2,FIELD_H/2, Math.max(W,FIELD_H)*0.7);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.18)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,FIELD_H);
  ctx.strokeStyle='#00000010'; ctx.lineWidth=1; ctx.beginPath();
  for(let y=0;y<=FIELD_H;y+=64){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  for(let x=0;x<=W;x+=80){ ctx.moveTo(x,0); ctx.lineTo(x,FIELD_H); }
  ctx.stroke();
  ctx.strokeStyle='#a99f72aa'; ctx.lineWidth=2;
  for(const x of COL_X){ ctx.beginPath(); ctx.moveTo(x,20); ctx.lineTo(x,FIELD_H-20); ctx.stroke(); }
  ctx.fillStyle=tex.dirt; ctx.fillRect(0,RIVER_Y-28,W,12); ctx.fillRect(0,RIVER_Y+16,W,12);
  const t=state.time||0, h=26;
  const grad=ctx.createLinearGradient(0,RIVER_Y-h/2,0,RIVER_Y+h/2);
  grad.addColorStop(0,'#b4ecff'); grad.addColorStop(.5,'#79c6e2'); grad.addColorStop(1,'#5ab3d3');
  ctx.fillStyle=grad; ctx.fillRect(0,RIVER_Y-h/2,W,h);
  ctx.save(); ctx.globalAlpha=0.22; ctx.fillStyle='#ffffff';
  for(let i=0;i<3;i++){
    ctx.beginPath(); ctx.moveTo(0,RIVER_Y+Math.sin(t*1.2+i)*3);
    for(let x=0;x<=W;x+=12){ const y = RIVER_Y + Math.sin((x*0.02)+(t*1.2+i))*3; ctx.lineTo(x,y); }
    ctx.lineTo(W,RIVER_Y+h/2); ctx.lineTo(0,RIVER_Y+h/2); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
  const bridge=(cx)=>{
    softShadow(cx,RIVER_Y+14,70,12,0.28);
    ctx.save(); ctx.translate(cx,RIVER_Y);
    const g=ctx.createLinearGradient(-64,-18,-64,18);
    g.addColorStop(0,'#a86a33'); g.addColorStop(1,'#7a4a22');
    ctx.fillStyle=g; ctx.fillRect(-64,-18,128,36);
    ctx.strokeStyle='#5d3b1d'; ctx.lineWidth=3; ctx.strokeRect(-64,-18,128,36);
    ctx.strokeStyle='#6d461f';
    for(let i=-58;i<=58;i+=14){ ctx.beginPath(); ctx.moveTo(i,-18); ctx.lineTo(i,18); ctx.stroke(); }
    ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fillRect(-64,-18,128,4);
    ctx.restore();
  };
  bridge(W*0.3); bridge(W*0.7);
  ctx.fillStyle='#1a7fff18'; ctx.fillRect(COL_X[selectedCol]-W*0.16,0,W*0.32,FIELD_H);
}
function tower(t,friendly){
  softShadow(t.x,t.y+12,30,10,0.28);
  const body=ctx.createLinearGradient(t.x,t.y-26,t.x,t.y+26);
  body.addColorStop(0,'#d6dee8'); body.addColorStop(.5,'#b7c2cf'); body.addColorStop(1,'#a5b1bf');
  ctx.fillStyle=body; ctx.beginPath(); ctx.ellipse(t.x,t.y,26,24,0,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#8795a6'; ctx.lineWidth=3; ctx.beginPath(); ctx.ellipse(t.x,t.y,26,24,0,0,Math.PI*2); ctx.stroke();
  ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=8;
  ctx.fillStyle = friendly ? '#3b7ae0' : '#d14f4f'; ctx.beginPath(); ctx.arc(t.x,t.y,18,0,Math.PI*2); ctx.fill(); ctx.restore();
  ctx.fillStyle='#1e2935'; ctx.fillRect(t.x-6,t.y-3,12,10);
  ctx.save(); ctx.globalAlpha=.8;
  const flame=ctx.createRadialGradient(t.x+20,t.y-10,0,t.x+20,t.y-10,12);
  flame.addColorStop(0,'rgba(255,210,100,0.9)'); flame.addColorStop(1,'rgba(255,140,60,0)');
  ctx.fillStyle=flame; ctx.beginPath(); ctx.arc(t.x+20,t.y-10,12,0,Math.PI*2); ctx.fill(); ctx.restore();
  const sway=Math.sin(state.time*2+t.x)*3;
  ctx.fillStyle = friendly ? '#6fe0ff' : '#ffd46f';
  ctx.beginPath(); ctx.moveTo(t.x+24,t.y-14); ctx.lineTo(t.x+24+18+sway,t.y-18); ctx.lineTo(t.x+24,t.y-22); ctx.closePath(); ctx.fill();
  const w=78,h=8; ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(t.x-w/2,t.y-40,w,h);
  const hp=ctx.createLinearGradient(t.x-w/2,0,t.x+w/2,0); hp.addColorStop(0,'#6be675'); hp.addColorStop(1,'#32c24b');
  ctx.fillStyle=hp; ctx.fillRect(t.x-w/2,t.y-40,w*clamp(t.hp/t.max,0,1),h);
}
function drawUnit(u){
  ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle=(u.team==='P')?'#7fb6ff':'#ff9b9b';
  ctx.beginPath(); ctx.ellipse(u.x - u.dir*10, u.y+10, 18, 6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
  softShadow(u.x,u.y+8,16,6,0.25);
  const edge=(u.team==='P')?'#0b4ea2':'#9b1c1c';
  const core=(u.team==='P')?'#2f80ed':'#eb5757';
  const rim=ctx.createLinearGradient(u.x-16,u.y-16,u.x+16,u.y+16);
  rim.addColorStop(0,'#ffffff20'); rim.addColorStop(1,'#00000015');
  ctx.lineWidth=2; ctx.strokeStyle=edge;
  if(u.type==='tank'){
    const grd=ctx.createLinearGradient(u.x,u.y-12,u.x,u.y+12);
    grd.addColorStop(0,'#b1b6bf'); grd.addColorStop(1,core);
    ctx.fillStyle=grd; ctx.fillRect(u.x-18,u.y-13,36,26); ctx.strokeRect(u.x-18,u.y-13,36,26);
    ctx.fillStyle=rim; ctx.fillRect(u.x-18,u.y-13,36,6);
  }else if(u.type==='scout'){
    const g=ctx.createRadialGradient(u.x,u.y,2,u.x,u.y,14);
    g.addColorStop(0,'#ffffff'); g.addColorStop(1,core);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke();
  }else if(u.type==='spark'){
    const g=ctx.createRadialGradient(u.x,u.y,2,u.x,u.y,18);
    g.addColorStop(0,'#fffacd'); g.addColorStop(1,(u.team==='P')?'#7fb6ff':'#ff9b9b');
    ctx.fillStyle=g; ctx.beginPath(); ctx.moveTo(u.x-14,u.y+12); ctx.lineTo(u.x+14,u.y+12); ctx.lineTo(u.x,u.y-14); ctx.closePath(); ctx.fill();
    ctx.strokeStyle=edge; ctx.stroke();
    ctx.save(); ctx.globalAlpha=0.25; ctx.fillStyle=g; ctx.beginPath(); ctx.arc(u.x,u.y,20,0,Math.PI*2); ctx.fill(); ctx.restore();
  }else{ // healer
    ctx.fillStyle='#7cd37c'; ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#2d7a2d'; ctx.stroke();
    ctx.fillStyle='#2d7a2d'; ctx.fillRect(u.x-2,u.y-8,4,16); ctx.fillRect(u.x-8,u.y-2,16,4);
  }
  const ratio=clamp(u.hp/u.maxhp,0,1);
  ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(u.x-12,u.y-22,24,5);
  const g2=ctx.createLinearGradient(u.x-12,0,u.x+12,0); g2.addColorStop(0,'#7af07a'); g2.addColorStop(1,'#40c15b');
  ctx.fillStyle=g2; ctx.fillRect(u.x-12,u.y-22,24*ratio,5);
}
function drawProjectiles(){
  for(const p of state.projectiles){
    ctx.save(); ctx.globalAlpha=0.3;
    const trail=ctx.createLinearGradient(p.x - p.vx*0.02, p.y - p.vy*0.02, p.x, p.y);
    trail.addColorStop(0,'rgba(255,255,255,0)');
    trail.addColorStop(1, p.colorB);
    ctx.strokeStyle=trail; ctx.lineWidth=3; ctx.beginPath();
    ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02); ctx.lineTo(p.x, p.y); ctx.stroke();
    ctx.restore();
    const glow=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,8);
    glow.addColorStop(0,p.colorA); glow.addColorStop(1,'rgba(255,255,255,0)');
    ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle=p.colorB; ctx.beginPath(); ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2); ctx.fill();
  }
}
function drawCrowns(){
  ctx.fillStyle='#0f1115aa'; ctx.fillRect(0,0,W,22);
  ctx.font='bold 14px system-ui'; ctx.textAlign='left'; ctx.fillStyle='#ffd966';
  ctx.fillText('üî± '+state.crowns.you, 10, 16);
  ctx.textAlign='right'; ctx.fillText(state.crowns.enemy+' üî±', W-10, 16);
}

/* ================== UI & Mana ================== */
const cards=[
  {label:'Scout (3)',type:'scout',cost:3},
  {label:'Tank (4)', type:'tank', cost:4},
  {label:'Spark (2)',type:'spark',cost:2},
  {label:'Healer (3)',type:'healer',cost:3},
  {label:'Riavvia',  type:'restart',cost:0},
];
const cardRects=[];
function drawManaBar(){
  const x=24,y=FIELD_H+16,w=W-48,h=14;
  const m=state.manaP,M=state.manaMax;
  ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(x,y,w,h);
  const g=ctx.createLinearGradient(x,0,x+w,0); g.addColorStop(0,'#6fe0ff'); g.addColorStop(1,'#2b74ff');
  ctx.fillStyle=g; ctx.fillRect(x,y,w*(m/M),h);
  ctx.fillStyle='#00000066'; ctx.fillRect(x,y,w,2); ctx.fillRect(x,y+h-2,w,2);
  ctx.font='bold 14px system-ui'; ctx.textAlign='left'; ctx.fillStyle='#b9d7ff';
  ctx.fillText('Mana: '+Math.floor(m)+' / '+M, x, y-4);
  if(notEnoughManaBlink>0){
    ctx.save(); ctx.globalAlpha=Math.min(1,notEnoughManaBlink);
    ctx.fillStyle='#ff9b9b'; ctx.fillText('Mana insufficiente!', x+140, y-4);
    ctx.restore();
  }
}
function drawCards(){
  const pad=18, h=62, y=FIELD_H+44; cardRects.length=0;
  const total=cards.length, w=(W - pad*2 - (total-1)*12)/total;
  ctx.font='600 18px system-ui'; ctx.textAlign='center';
  for(let i=0;i<total;i++){
    const x=pad + i*(w+12);
    cardRects.push({x,y,w,h,i});
    const c=cards[i];
    ctx.fillStyle='rgba(16,24,32,.8)'; ctx.fillRect(x,y,w,h);
    ctx.strokeStyle='#2b74ff55'; ctx.lineWidth=2; ctx.strokeRect(x+.5,y+.5,w-1,h-1);
    ctx.fillStyle='#dbe8ff';
    ctx.fillText(c.label, x+w/2, y+39);
  }
}
function ui(){
  ctx.fillStyle='#0b1118'; ctx.fillRect(0,FIELD_H,W,UI_H);
  drawManaBar();
  drawCards();
}

/* ================== Input ================== */
canvas.addEventListener('pointerdown',ev=>{
  const p=toLogical(ev);
  if(p.y<FIELD_H){
    let idx=0, best=1e9;
    for(let i=0;i<3;i++){ const d=Math.abs(p.x-COL_X[i]); if(d<best){best=d; idx=i;} }
    selectedCol=idx;
    return;
  }
  for(const r of cardRects){
    if(p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h){
      const card=cards[r.i];
      if(card.type==='restart'){ restart(); return; }
      if(state.manaP>=card.cost){
        state.manaP-=card.cost;
        addUnit('P', selectedCol, card.type);
      }else{
        notEnoughManaBlink=1.2;
      }
      return;
    }
  }
});

/* ================== Restart ================== */
function restart(){
  state.units.length=0; state.floats.length=0; state.particles.length=0; state.projectiles.length=0;
  for(const t of state.playerTowers){ t.hp=t.max; t.cd=0; }
  for(const t of state.enemyTowers){ t.hp=t.max; t.cd=0; }
  state.manaP=5; state.manaE=5; state.time=0; state.match.t=0; state.playing=true;
}

/* ================== Main loop ================== */
function frame(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  ctx.save();
  ctx.setTransform(scale,0,0,scale,offX,offY);
  ctx.fillStyle='#0f1115'; ctx.fillRect(-offX/scale,-offY/scale,canvas.width/scale,canvas.height/scale);
  if(notEnoughManaBlink>0) notEnoughManaBlink-=dt;
  step(dt);
  bg();
  state.enemyTowers.forEach(t=>tower(t,false));
  state.playerTowers.forEach(t=>tower(t,true));
  state.units.forEach(drawUnit);
  drawProjectiles();
  for(const p of state.particles){ ctx.fillStyle=p.c; ctx.globalAlpha=1-(p.t/p.life); ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha=1; }
  ctx.font='bold 14px system-ui'; ctx.textAlign='center';
  for(const f of state.floats){ ctx.fillStyle=f.c; ctx.globalAlpha=1-f.t; ctx.fillText(f.v, f.x, f.y); ctx.globalAlpha=1; }
  drawCrowns();
  ui();
  ctx.restore();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
