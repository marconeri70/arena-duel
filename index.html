<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Arena Duel ‚Äì Realistic Vertical</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #050608;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #fff;
    overscroll-behavior: none;
  }
  canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    background: #050608;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ============================================================
   1. CANVAS & SCALING (VERTICALE)
   ============================================================ */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

const LOGICAL_W = 720;
const LOGICAL_H = 1280;
const UI_H = 210;
const FIELD_H = LOGICAL_H - UI_H;
const RIVER_Y = FIELD_H * 0.50;
const LANES_X = [LOGICAL_W*0.18, LOGICAL_W*0.50, LOGICAL_W*0.82];

let scale = 1, offX = 0, offY = 0;

function resize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.max(1, Math.round(rect.width * dpr));
  canvas.height = Math.max(1, Math.round(rect.height * dpr));
  scale = Math.min(canvas.width / LOGICAL_W, canvas.height / LOGICAL_H);
  offX = Math.floor((canvas.width  - LOGICAL_W * scale) / 2);
  offY = Math.floor((canvas.height - LOGICAL_H * scale) / 2);
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);
resize();

function toLogical(evt) {
  const rect = canvas.getBoundingClientRect();
  const px = (evt.clientX - rect.left) * (canvas.width/rect.width);
  const py = (evt.clientY - rect.top ) * (canvas.height/rect.height);
  return {
    x: (px - offX) / scale,
    y: (py - offY) / scale
  };
}

/* ============================================================
   2. UTILITY
   ============================================================ */
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const rand  = (a,b)=>a + Math.random()*(b-a);

function softShadow(x,y,rx,ry,a=0.24) {
  ctx.save();
  ctx.globalAlpha = a;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* ============================================================
   3. GAME STATE
   ============================================================ */
const state = {
  time: 0,
  running: true,
  mana: 7,
  manaMax: 13,
  manaRegen: 2.4, // per secondo
  enemyMana: 7,
  enemyManaRegen: 2.0,
  matchTime: 0,
  matchDuration: 120,
  selectedLane: 1,
  selectedCard: null,
  notEnoughBlink: 0,
  units: [],
  projectiles: [],
  floats: [],
  particles: [],
  crowns: {you:0, enemy:0},
  // Torri: lane 0 = sinistra, lane 2 = destra
  playerTowers: [
    {lane:0,x:LANES_X[0],y:FIELD_H-95,hp:140,max:140},
    {lane:2,x:LANES_X[2],y:FIELD_H-95,hp:140,max:140}
  ],
  enemyTowers: [
    {lane:0,x:LANES_X[0],y:95,hp:140,max:140},
    {lane:2,x:LANES_X[2],y:95,hp:140,max:140}
  ],
  // Cristallo di mana centrale
  crystal:{
    lane:1,
    x:LANES_X[1],
    y:RIVER_Y+10,
    hp:90,
    max:90,
    alive:true,
    lastHit:null
  }
};

const CARDS = [
  {id:"scout",  label:"Scout",  cost:3},
  {id:"spark",  label:"Spark",  cost:2},
  {id:"tank",   label:"Tank",   cost:4},
  {id:"healer", label:"Healer", cost:3},
  {id:"restart",label:"Riavvia",cost:0}
];
const cardRects = [];

/* ============================================================
   4. FLOATING TEXT & PARTICLES
   ============================================================ */
function addFloat(x,y,text,color="#fff") {
  state.floats.push({x,y,text,color,t:0,life:0.9});
}
function addHitParticles(x,y,color="#ffb36a") {
  for (let i=0;i<10;i++) {
    state.particles.push({
      x,y,
      vx: rand(-1,1),
      vy: rand(-1.5,-0.3),
      g: 0.04,
      t: 0,
      life: rand(0.3,0.7),
      color
    });
  }
}

/* ============================================================
   5. DAMAGE / HEAL HELPERS
   ============================================================ */
function applyDamage(target,amount) {
  if (!target || target.hp<=0) return;
  target.hp -= amount;
  addHitParticles(target.x,target.y-6, amount>0 ? "#ffb36a" : "#7cf6a2");
  addFloat(target.x,target.y-24,(amount>0?"-":"+")+Math.round(Math.abs(amount)),
           amount>0?"#ffb36a":"#7cf6a2");
}
function applyHeal(target,amount) {
  if (!target || target.hp<=0) return;
  const before = target.hp;
  target.hp = Math.min(target.max, target.hp + amount);
  if (target.hp>before) {
    addHitParticles(target.x,target.y-6,"#7cf6a2");
    addFloat(target.x,target.y-24,"+"+Math.round(target.hp-before),"#7cf6a2");
  }
}

/* ============================================================
   6. UNIT√Ä E PROIETTILI
   ============================================================ */
function spawnUnit(team,lane,type) {
  const x = LANES_X[lane];
  const dir = (team==="P") ? -1 : 1;
  const y = (team==="P") ? (FIELD_H-150) : 150;
  const base = {
    team,lane,x,y,dir,
    cd:0,
    animT:0,
    vx:0,vy:0
  };
  if (type==="scout") {
    Object.assign(base,{type,spd:80,hp:30,max:30,atk:6,range:30,rate:0.6});
  } else if (type==="spark") {
    Object.assign(base,{type,spd:55,hp:20,max:20,atk:12,range:130,rate:0.9});
  } else if (type==="tank") {
    Object.assign(base,{type,spd:40,hp:80,max:80,atk:10,range:30,rate:0.9});
  } else if (type==="healer") {
    Object.assign(base,{type,spd:55,hp:26,max:26,atk:-10,range:110,rate:0.9});
  }
  state.units.push(base);
}

function spawnProjectile(from,target,opts) {
  const dx = target.x - from.x;
  const dy = target.y - from.y;
  const len = Math.hypot(dx,dy)||1;
  const speed = opts.speed || 260;
  state.projectiles.push({
    x:from.x,
    y:from.y,
    vx:(dx/len)*speed,
    vy:(dy/len)*speed,
    team:opts.team,
    heal: !!opts.heal,
    dmg: opts.dmg || 8,
    life:1.3,
    colorA:opts.colorA || "#fffacd",
    colorB:opts.colorB || "#7fb6ff"
  });
}

/* ============================================================
   7. IA SEMPLICE NEMICO
   ============================================================ */
let aiTimer = 2;
function aiUpdate(dt) {
  aiTimer -= dt;
  state.enemyMana = clamp(state.enemyMana + state.enemyManaRegen*dt,0,13);
  if (!state.running) return;
  if (aiTimer<=0) {
    aiTimer = rand(1.3,2.4);
    const m = Math.floor(state.enemyMana);
    const choices=[];
    if (m>=2) choices.push("spark");
    if (m>=3) choices.push("scout","healer");
    if (m>=4) choices.push("tank");
    if (!choices.length) return;
    const t = choices[(Math.random()*choices.length)|0];
    const cost = t==="tank"?4:(t==="spark"?2:3);
    state.enemyMana -= cost;
    const lane = (Math.random()*3)|0;
    spawnUnit("E",lane,t);
  }
}

/* ============================================================
   8. TARGETING (INCLUDE CRISTALLO CENTRALE!)
   ============================================================ */
function nearestTargetForUnit(u) {
  const enemyTeam = (u.team==="P") ? "E" : "P";
  const foes = state.units.filter(o => o.team===enemyTeam && o.lane===u.lane && o.hp>0);
  const enemyTowers = (enemyTeam==="E"?state.enemyTowers:state.playerTowers)
    .filter(t => t.lane===u.lane && t.hp>0);

  let candidate = null;
  let bestScore = Infinity;

  // 1) unit√† nemiche nella stessa corsia
  for (const f of foes) {
    const score = Math.abs(f.y - u.y);
    if (score < bestScore) { bestScore=score; candidate=f; }
  }

  // 2) torri nella stessa corsia
  for (const t of enemyTowers) {
    const score = Math.abs(t.y - u.y) + 40;
    if (score < bestScore) { bestScore=score; candidate=t; }
  }

  // 3) CRISTALLO centrale (solo lane 1)
  if (u.lane===1 && state.crystal.alive && state.crystal.hp>0) {
    const score = Math.abs(state.crystal.y - u.y) + 20;
    if (score < bestScore) {
      bestScore = score;
      candidate = state.crystal;
    }
  }

  return candidate;
}

/* ============================================================
   9. UPDATE LOGIC (MOVIMENTO, ATTACCHI, CRISTALLO)
   ============================================================ */
function resetGame() {
  state.time = 0;
  state.matchTime = 0;
  state.running = true;
  state.mana = 7;
  state.manaMax = 13;
  state.enemyMana = 7;
  state.units = [];
  state.projectiles = [];
  state.floats = [];
  state.particles = [];
  state.crowns = {you:0,enemy:0};

  state.playerTowers.forEach(t=>{t.hp=t.max;});
  state.enemyTowers.forEach(t=>{t.hp=t.max;});
  state.crystal.hp = state.crystal.max;
  state.crystal.alive = true;
  state.crystal.lastHit = null;
}

function onCrystalDestroyed(team) {
  if (!state.crystal.alive) return;
  state.crystal.alive = false;
  addFloat(state.crystal.x,state.crystal.y-40,
           team==="P"?"BONUS MANA!":"+MANAGER NEMICO!","#4ff5ff");
  addHitParticles(state.crystal.x,state.crystal.y-10,"#4ff5ff");
  if (team==="P") {
    state.manaMax += 3;
    state.mana = clamp(state.mana + 5,0,state.manaMax);
  } else {
    state.enemyMana = clamp(state.enemyMana + 5,0,13);
  }
}

function update(dt) {
  state.time += dt;
  if (state.running) {
    state.matchTime += dt;
    state.mana = clamp(state.mana + state.manaRegen*dt, 0, state.manaMax);

    if (state.matchTime >= state.matchDuration) {
      state.running = false;
    }
  }

  aiUpdate(dt);

  // Torri & corone
  const pAlive = state.playerTowers.filter(t=>t.hp>0).length;
  const eAlive = state.enemyTowers.filter(t=>t.hp>0).length;
  state.crowns.you   = 2 - eAlive;
  state.crowns.enemy = 2 - pAlive;
  if (state.running && (pAlive===0 || eAlive===0)) {
    state.running = false;
  }

  // Unit√†
  const minGap = 32;
  for (const u of state.units) {
    if (u.hp<=0) continue;
    u.cd -= dt;
    u.animT += dt;

    const target = nearestTargetForUnit(u);
    if (!target) {
      // nessun bersaglio ‚Üí avanza
      u.y += u.dir * u.spd * dt;
    } else {
      const dist = Math.hypot(target.x-u.x, target.y-u.y);
      const inRange = (u.type==="spark" || u.type==="healer")
        ? (dist <= u.range)
        : (dist <= u.range+4);

      if (inRange && u.cd<=0 && state.running) {
        u.cd = u.rate;
        // ranged / healer
        if (u.type==="spark" || u.type==="healer") {
          const heal = (u.type==="healer");
          const dmg = heal ? Math.abs(u.atk) : u.atk;
          spawnProjectile(u,target,{
            team:u.team,
            heal:heal,
            dmg:dmg,
            speed: heal?220:320,
            colorA: heal?"#a6ffcb":"#fff6b3",
            colorB: heal?"#4de483":(u.team==="P"?"#7fb6ff":"#ff9b9b")
          });
        } else {
          // melee
          if (target===state.crystal) {
            state.crystal.hp -= u.atk;
            state.crystal.lastHit = u.team;
            addHitParticles(target.x,target.y-6,u.team==="P"?"#7fb6ff":"#ff9b9b");
            if (state.crystal.hp<=0) onCrystalDestroyed(u.team);
          } else {
            applyDamage(target,u.atk);
          }
        }
      } else if (!inRange) {
        // avanza verso il nemico
        u.y += u.dir * u.spd * dt;
      }
    }
  }

  // Anti-sorpasso (le unit√† non superano la prima della fila)
  for (const team of ["P","E"]) {
    for (let lane=0; lane<3; lane++) {
      const dir = (team==="P")?-1:1;
      const laneUnits = state.units
        .filter(u=>u.team===team && u.lane===lane && u.hp>0)
        .sort((a,b)=> (a.y-b.y)*dir);
      for (let i=1;i<laneUnits.length;i++) {
        const front = laneUnits[i-1];
        const back  = laneUnits[i];
        const desired = front.y - dir*minGap;
        if ((dir===-1 && back.y<desired) || (dir===1 && back.y>desired)) {
          back.y = desired;
        }
      }
    }
  }

  // Proiettili
  for (const p of state.projectiles) {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    if (p.life<=0) continue;

    const enemyTeam = (p.team==="P") ? "E" : "P";

    // bersagli possibili
    const targets = [];
    // unit√†
    state.units.forEach(u=>{
      if (u.hp>0 && ((p.heal && u.team===p.team) || (!p.heal && u.team===enemyTeam))) {
        targets.push(u);
      }
    });
    // torri
    const towers = p.heal
      ? (p.team==="P"?state.playerTowers:state.enemyTowers)
      : (p.team==="P"?state.enemyTowers:state.playerTowers);
    towers.forEach(t=>{
      if (t.hp>0) targets.push(t);
    });
    // cristallo
    if (!p.heal && state.crystal.alive && state.crystal.hp>0) {
      targets.push(state.crystal);
    }

    let hit = null;
    for (const t of targets) {
      const radius = (t===state.crystal)?22:(t.max>=140?26:16);
      const d = Math.hypot(t.x-p.x, t.y-p.y);
      if (d < radius) { hit=t; break; }
    }
    if (hit) {
      if (p.heal) {
        applyHeal(hit,p.dmg);
      } else {
        if (hit===state.crystal) {
          state.crystal.hp -= p.dmg;
          state.crystal.lastHit = p.team;
          if (state.crystal.hp<=0) onCrystalDestroyed(p.team);
        } else {
          applyDamage(hit,p.dmg);
        }
      }
      p.life = 0;
    }
  }

  state.projectiles = state.projectiles.filter(p=>p.life>0);

  // pulizia
  state.units = state.units.filter(u=>u.hp>0 && u.y>40 && u.y<FIELD_H-40);
  state.floats.forEach(f=>{f.t+=dt; f.y-=24*dt;});
  state.floats = state.floats.filter(f=>f.t<f.life);
  state.particles.forEach(pp=>{
    pp.t+=dt;
    pp.x += pp.vx*60*dt;
    pp.y += pp.vy*60*dt;
    pp.vy += pp.g;
  });
  state.particles = state.particles.filter(pp=>pp.t<pp.life);

  if (state.notEnoughBlink>0) state.notEnoughBlink-=dt*2;
}

/* ============================================================
   10. RENDER ‚Äì SFONDO, TORRI, CRISTALLO, UNIT√Ä, UI
   ============================================================ */
function drawBackground() {
  // erba realistica
  const grd = ctx.createLinearGradient(0,0,0,FIELD_H);
  grd.addColorStop(0,"#d7e2a4");
  grd.addColorStop(1,"#c3d28a");
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,LOGICAL_W,FIELD_H);

  // texture erba
  ctx.save();
  ctx.strokeStyle="rgba(70,100,40,0.18)";
  ctx.lineWidth=1;
  for (let i=0;i<900;i++) {
    const x = Math.random()*LOGICAL_W;
    const y = Math.random()*FIELD_H;
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x+rand(-4,4),y+rand(4,8));
    ctx.stroke();
  }
  ctx.restore();

  // zone corsie
  ctx.fillStyle="rgba(0,0,0,0.08)";
  for (let i=0;i<3;i++) {
    if (i===state.selectedLane) {
      ctx.fillStyle="rgba(0,80,200,0.16)";
    } else {
      ctx.fillStyle="rgba(0,0,0,0.06)";
    }
    const left = (i===0?0:(i===1?LOGICAL_W*0.34:LOGICAL_W*0.66));
    const width = (i===1?LOGICAL_W*0.32:LOGICAL_W*0.34);
    ctx.fillRect(left,0,width,FIELD_H);
  }

  // griglia
  ctx.strokeStyle="rgba(0,0,0,0.10)";
  ctx.lineWidth=1;
  ctx.beginPath();
  for (let y=0;y<=FIELD_H;y+=80) {
    ctx.moveTo(0,y); ctx.lineTo(LOGICAL_W,y);
  }
  for (let x=0;x<=LOGICAL_W;x+=90) {
    ctx.moveTo(x,0); ctx.lineTo(x,FIELD_H);
  }
  ctx.stroke();

  // fiume
  const waterH = 34;
  const wgrd = ctx.createLinearGradient(0,RIVER_Y-waterH/2,0,RIVER_Y+waterH/2);
  wgrd.addColorStop(0,"#b8ecff");
  wgrd.addColorStop(0.5,"#7bc1e6");
  wgrd.addColorStop(1,"#4d9ac9");
  ctx.fillStyle = wgrd;
  ctx.fillRect(0,RIVER_Y-waterH/2,LOGICAL_W,waterH);

  // sponde
  ctx.fillStyle="#c29f70";
  ctx.fillRect(0,RIVER_Y-waterH/2-10,LOGICAL_W,10);
  ctx.fillRect(0,RIVER_Y+waterH/2,LOGICAL_W,10);

  // ponti
  function drawBridge(cx) {
    softShadow(cx,RIVER_Y+14,80,14,0.33);
    ctx.save();
    ctx.translate(cx,RIVER_Y);
    const bg = ctx.createLinearGradient(-70,-20,-70,20);
    bg.addColorStop(0,"#9b6a3a");
    bg.addColorStop(1,"#6e4320");
    ctx.fillStyle = bg;
    ctx.fillRect(-70,-20,140,40);
    ctx.strokeStyle="#4b2b14";
    ctx.lineWidth=3;
    ctx.strokeRect(-70,-20,140,40);
    ctx.strokeStyle="#5c3519";
    for (let x=-60;x<=60;x+=14) {
      ctx.beginPath();
      ctx.moveTo(x,-20); ctx.lineTo(x,20); ctx.stroke();
    }
    ctx.restore();
  }
  drawBridge(LOGICAL_W*0.30);
  drawBridge(LOGICAL_W*0.70);

  // etichette corsie A / B / C in alto
  ctx.fillStyle="rgba(0,0,0,0.70)";
  ctx.fillRect(0,22,LOGICAL_W,22);
  ctx.font="bold 16px system-ui";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  const labels=["A","B","C"];
  for (let i=0;i<3;i++) {
    ctx.fillStyle= i===state.selectedLane ? "#ffe07a" : "#e0e6ff";
    ctx.fillText(labels[i], LANES_X[i], 33);
  }
}

function drawTower(t,friendly) {
  if (t.hp<=0) return;
  softShadow(t.x,t.y+14,32,12,0.32);
  // base in pietra
  const body = ctx.createLinearGradient(t.x,t.y-32,t.x,t.y+26);
  body.addColorStop(0,"#d8dfea");
  body.addColorStop(0.5,"#b4bfcc");
  body.addColorStop(1,"#9aa7b8");
  ctx.fillStyle = body;
  ctx.beginPath();
  ctx.roundRect(t.x-26,t.y-32,52,52,8);
  ctx.fill();
  ctx.strokeStyle="#707f91";
  ctx.lineWidth=2;
  ctx.stroke();

  // merlature
  ctx.fillStyle="#f2f4f7";
  ctx.fillRect(t.x-28,t.y-38,56,10);
  ctx.strokeStyle="#707f91";
  ctx.strokeRect(t.x-28,t.y-38,56,10);

  // scudo colorato
  ctx.beginPath();
  ctx.arc(t.x,t.y-6,14,0,Math.PI*2);
  ctx.fillStyle = friendly ? "#2f6fe8" : "#d34747";
  ctx.fill();
  ctx.strokeStyle="#18263a";
  ctx.stroke();

  // ferito?
  if (t.hp < t.max*0.35) {
    ctx.fillStyle="#ffb36a";
    ctx.beginPath();
    ctx.moveTo(t.x-6,t.y-24);
    ctx.lineTo(t.x+6,t.y-24);
    ctx.lineTo(t.x,t.y-36);
    ctx.closePath();
    ctx.fill();
  }

  // barra HP
  const ratio = clamp(t.hp/t.max,0,1);
  const barW = 80, barH = 8;
  ctx.fillStyle="rgba(0,0,0,0.55)";
  ctx.fillRect(t.x-barW/2,t.y-48,barW,barH);
  const hpGrad = ctx.createLinearGradient(t.x-barW/2,0,t.x+barW/2,0);
  hpGrad.addColorStop(0, ratio<0.35 ? "#ff6b6b" : "#6aed7b");
  hpGrad.addColorStop(1, ratio<0.35 ? "#ff9b6b" : "#36c85b");
  ctx.fillStyle = hpGrad;
  ctx.fillRect(t.x-barW/2,t.y-48,barW*ratio,barH);
}

function drawCrystal() {
  const c = state.crystal;
  if (!c.alive || c.hp<=0) return;
  softShadow(c.x,c.y+18,30,12,0.33);

  // piedistallo
  ctx.fillStyle="#2b2628";
  ctx.beginPath();
  ctx.roundRect(c.x-30,c.y+6,60,16,6);
  ctx.fill();

  // cristallo (rombo sfaccettato)
  const t = state.time;
  const floatY = Math.sin(t*2)*4;
  ctx.save();
  ctx.translate(c.x,c.y-4+floatY);

  const grad = ctx.createLinearGradient(0,-40,0,20);
  grad.addColorStop(0,"#e8f7ff");
  grad.addColorStop(0.4,"#8ecfff");
  grad.addColorStop(1,"#2f68c9");
  ctx.fillStyle = grad;
  ctx.strokeStyle="#15305a";
  ctx.lineWidth=2;

  ctx.beginPath();
  ctx.moveTo(0,-38);
  ctx.lineTo(22,-6);
  ctx.lineTo(0,26);
  ctx.lineTo(-22,-6);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // taglio centrale
  ctx.strokeStyle="rgba(255,255,255,0.5)";
  ctx.beginPath();
  ctx.moveTo(0,-38);
  ctx.lineTo(0,26);
  ctx.stroke();

  // alone
  const halo = ctx.createRadialGradient(0,0,0,0,0,40);
  halo.addColorStop(0,"rgba(164,220,255,0.8)");
  halo.addColorStop(1,"rgba(164,220,255,0)");
  ctx.globalAlpha=0.65;
  ctx.fillStyle=halo;
  ctx.beginPath();
  ctx.arc(0,0,40,0,Math.PI*2);
  ctx.fill();

  ctx.restore();

  // barra HP
  const ratio = clamp(c.hp/c.max,0,1);
  const barW=90, barH=8;
  ctx.fillStyle="rgba(0,0,0,0.60)";
  ctx.fillRect(c.x-barW/2,c.y-52,barW,barH);
  const hpGrad = ctx.createLinearGradient(c.x-barW/2,0,c.x+barW/2,0);
  hpGrad.addColorStop(0,"#6aedff");
  hpGrad.addColorStop(1,"#36a5ff");
  ctx.fillStyle=hpGrad;
  ctx.fillRect(c.x-barW/2,c.y-52,barW*ratio,barH);

  // testo
  ctx.font="12px system-ui";
  ctx.fillStyle="#e0f4ff";
  ctx.textAlign="center";
  ctx.fillText("Cristallo del Mana", c.x, c.y-60);
}

function drawUnit(u) {
  if (u.hp<=0) return;
  softShadow(u.x,u.y+10,18,8,0.30);

  const teamColor = (u.team==="P")?"#2f6fe8":"#d34747";
  const armorTop  = (u.team==="P")?"#e6edf7":"#f3d4d4";

  // corpo (piccolo cavaliere realistico stilizzato)
  ctx.save();
  ctx.translate(u.x,u.y);
  const wobble = Math.sin(u.animT*8)*1.5;
  ctx.translate(0,wobble);

  // armatura torace
  ctx.fillStyle="#c0cad8";
  ctx.strokeStyle="#6b768a";
  ctx.lineWidth=1.8;
  ctx.beginPath();
  ctx.roundRect(-12,-16,24,24,6);
  ctx.fill();
  ctx.stroke();

  // spalle
  ctx.fillStyle=armorTop;
  ctx.beginPath();
  ctx.ellipse(0,-18,14,6,0,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();

  // elmo
  ctx.fillStyle=teamColor;
  ctx.beginPath();
  ctx.arc(0,-22,10,Math.PI,0);
  ctx.fill();
  ctx.stroke();

  // visiera
  ctx.fillStyle="#1e2635";
  ctx.fillRect(-8,-23,16,5);

  // simbolo tipo
  if (u.type==="tank") {
    ctx.fillStyle="#f5a623";
    ctx.fillRect(-5,-7,10,10);
  } else if (u.type==="spark") {
    ctx.fillStyle="#ffe97a";
    ctx.beginPath();
    ctx.moveTo(0,-10); ctx.lineTo(6,2); ctx.lineTo(-6,2); ctx.closePath();
    ctx.fill();
  } else if (u.type==="healer") {
    ctx.fillStyle="#6eed7c";
    ctx.fillRect(-2,-10,4,12);
    ctx.fillRect(-6,-4,12,4);
  } else { // scout
    ctx.fillStyle="#9fd3ff";
    ctx.beginPath();
    ctx.arc(0,-10,6,0,Math.PI*2); ctx.fill();
  }

  ctx.restore();

  // barra HP
  const ratio = clamp(u.hp/u.max,0,1);
  ctx.fillStyle="rgba(0,0,0,0.55)";
  ctx.fillRect(u.x-14,u.y-26,28,5);
  const g = ctx.createLinearGradient(u.x-14,0,u.x+14,0);
  g.addColorStop(0, ratio<0.35 ? "#ff6b6b" : "#6aed7b");
  g.addColorStop(1, ratio<0.35 ? "#ff9b6b" : "#36c85b");
  ctx.fillStyle=g;
  ctx.fillRect(u.x-14,u.y-26,28*ratio,5);
}

function drawProjectiles() {
  for (const p of state.projectiles) {
    const trail = ctx.createLinearGradient(p.x-p.vx*0.05,p.y-p.vy*0.05,p.x,p.y);
    trail.addColorStop(0,"rgba(255,255,255,0)");
    trail.addColorStop(1,p.colorB);
    ctx.save();
    ctx.globalAlpha=0.35;
    ctx.strokeStyle=trail;
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(p.x-p.vx*0.05,p.y-p.vy*0.05);
    ctx.lineTo(p.x,p.y);
    ctx.stroke();
    ctx.restore();

    const glow = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,8);
    glow.addColorStop(0,p.colorA);
    glow.addColorStop(1,"rgba(255,255,255,0)");
    ctx.save();
    ctx.globalAlpha=0.9;
    ctx.fillStyle=glow;
    ctx.beginPath();
    ctx.arc(p.x,p.y,6,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle=p.colorB;
    ctx.beginPath();
    ctx.arc(p.x,p.y,2.4,0,Math.PI*2);
    ctx.fill();
  }
}

function drawUI() {
  // fascia nera in alto (testo / menu sintetico)
  ctx.fillStyle="rgba(0,0,0,0.90)";
  ctx.fillRect(0,0,LOGICAL_W,22);
  ctx.font="12px system-ui";
  ctx.textAlign="left";
  ctx.textBaseline="middle";
  ctx.fillStyle="#f0f4ff";
  ctx.fillText("Menu ‚Üí Gioca ‚Ä¢ In partita: tocca il campo per scegliere corsia, poi le carte",8,11);

  // riga suggerimento cristallo
  ctx.fillStyle="rgba(0,0,0,0.90)";
  ctx.fillRect(0,22,LOGICAL_W,22);
  ctx.textAlign="center";
  ctx.fillStyle="#ffe07a";
  ctx.fillText("La corsia centrale contiene il Cristallo del Mana: distruggerlo ti d√† bonus mana.",LOGICAL_W/2,33);

  // crowns
  ctx.font="16px system-ui";
  ctx.textAlign="left";
  ctx.fillStyle="#ffd66b";
  ctx.fillText("üëë "+state.crowns.you,8,LOGICAL_H-UI_H+18);
  ctx.textAlign="right";
  ctx.fillText(state.crowns.enemy+" üëë",LOGICAL_W-8,LOGICAL_H-UI_H+18);

  // mana bar
  const barX=20, barY=LOGICAL_H-UI_H+36, barW=LOGICAL_W-40, barH=16;
  ctx.fillStyle="rgba(0,0,0,0.65)";
  ctx.fillRect(barX,barY,barW,barH);
  const manaRatio = clamp(state.mana/state.manaMax,0,1);
  const manaGrad = ctx.createLinearGradient(barX,0,barX+barW,0);
  manaGrad.addColorStop(0,"#56ccf2");
  manaGrad.addColorStop(1,"#2f80ed");
  ctx.fillStyle=manaGrad;
  ctx.fillRect(barX,barY,barW*manaRatio,barH);
  ctx.font="12px system-ui";
  ctx.textAlign="left";
  ctx.fillStyle="#e8f4ff";
  ctx.fillText("Mana: "+state.mana.toFixed(0)+" / "+state.manaMax, barX+2, barY-4);

  // carte
  const cardsY = LOGICAL_H-UI_H+64;
  const cardW = (LOGICAL_W-40)/CARDS.length - 6;
  const cardH = 80;
  cardRects.length=0;
  CARDS.forEach((card,i)=>{
    const x = 20 + i*(cardW+6);
    const y = cardsY;
    const selected = (state.selectedCard===card.id);

    // sfondo
    const grad = ctx.createLinearGradient(x,y,x,y+cardH);
    grad.addColorStop(0, selected ? "#283a5f" : "#151a24");
    grad.addColorStop(1, selected ? "#111827" : "#0b0f17");
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.roundRect(x,y,cardW,cardH,10);
    ctx.fill();

    // bordo
    ctx.strokeStyle = selected ? "#4f8cff" : "#222837";
    ctx.lineWidth = selected ? 2.4 : 1.4;
    ctx.stroke();

    // tipo icona
    ctx.save();
    ctx.translate(x+cardW/2,y+26);
    if (card.id==="scout") {
      ctx.fillStyle="#9fd3ff";
      ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
    } else if (card.id==="spark") {
      ctx.fillStyle="#ffe97a";
      ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(12,8); ctx.lineTo(-12,8); ctx.closePath(); ctx.fill();
    } else if (card.id==="tank") {
      ctx.fillStyle="#f5a623";
      ctx.beginPath(); ctx.roundRect(-12,-10,24,20,4); ctx.fill();
    } else if (card.id==="healer") {
      ctx.fillStyle="#6eed7c";
      ctx.fillRect(-3,-12,6,24); ctx.fillRect(-12,-3,24,6);
    } else { // restart
      ctx.strokeStyle="#e5e7eb";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(0,0,10,Math.PI*0.4,Math.PI*1.8);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(8,-7); ctx.lineTo(13,-12); ctx.lineTo(13,-5); ctx.closePath();
      ctx.fillStyle="#e5e7eb"; ctx.fill();
    }
    ctx.restore();

    // nome + costo
    ctx.textAlign="center";
    ctx.fillStyle="#e5e7eb";
    ctx.font="13px system-ui";
    ctx.fillText(card.label, x+cardW/2, y+cardH-28);
    ctx.font="11px system-ui";
    if (card.id!=="restart") {
      ctx.fillStyle = state.mana>=card.cost ? "#9be8ff" : "#fca5a5";
      ctx.fillText(card.cost.toString(), x+cardW/2, y+cardH-10);
    } else {
      ctx.fillStyle="#9be8ff";
      ctx.fillText("‚Ü∫", x+cardW/2, y+cardH-10);
    }

    cardRects.push({id:card.id,x,y,w:cardW,h:cardH});
  });

  // messaggio fine partita
  if (!state.running) {
    ctx.fillStyle="rgba(0,0,0,0.65)";
    ctx.fillRect(40,FIELD_H/2-60,LOGICAL_W-80,120);
    ctx.textAlign="center";
    ctx.fillStyle="#fff";
    ctx.font="bold 26px system-ui";
    const you = state.crowns.you;
    const enemy = state.crowns.enemy;
    let msg = "Pareggio";
    if (you>enemy) msg="Vittoria!";
    else if (enemy>you) msg="Sconfitta";
    ctx.fillText(msg, LOGICAL_W/2, FIELD_H/2-10);
    ctx.font="14px system-ui";
    ctx.fillStyle="#e5e7eb";
    ctx.fillText("Tocca 'Riavvia' per giocare ancora", LOGICAL_W/2, FIELD_H/2+22);
  }

  // lampeggio mana insufficiente
  if (state.notEnoughBlink>0) {
    ctx.fillStyle="rgba(255,80,80,0.18)";
    ctx.fillRect(0,FIELD_H,LOGICAL_W,LOGICAL_H-FIELD_H);
  }

  // floating text
  state.floats.forEach(f=>{
    ctx.globalAlpha = 1 - f.t/f.life;
    ctx.fillStyle=f.color;
    ctx.textAlign="center";
    ctx.font="13px system-ui";
    ctx.fillText(f.text,f.x,f.y);
    ctx.globalAlpha = 1;
  });

  // particles
  state.particles.forEach(p=>{
    const alpha = 1 - p.t/p.life;
    ctx.globalAlpha = alpha;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,2,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}

/* ============================================================
   11. MAIN LOOP
   ============================================================ */
let lastTime = performance.now();
function loop(now) {
  const dt = Math.min(0.033, (now-lastTime)/1000);
  lastTime = now;

  update(dt);

  // clear & transform
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offX,offY);

  drawBackground();
  state.playerTowers.forEach(t=>drawTower(t,true));
  state.enemyTowers.forEach(t=>drawTower(t,false));
  drawCrystal();
  state.units.forEach(drawUnit);
  drawProjectiles();
  drawUI();

  requestAnimationFrame(loop);
}
resetGame();
requestAnimationFrame(loop);

/* ============================================================
   12. INPUT TOUCH / MOUSE
   ============================================================ */
function onPointerDown(evt) {
  const p = ("touches" in evt) ? evt.touches[0] : evt;
  const pos = toLogical(p);
  if (pos.y < 0 || pos.y > LOGICAL_H) return;
  if (pos.y <= FIELD_H) {
    // seleziona corsia
    let best = 0, bestDist = Infinity;
    LANES_X.forEach((x,i)=>{
      const d = Math.abs(pos.x-x);
      if (d<bestDist){bestDist=d; best=i;}
    });
    state.selectedLane = best;
  } else {
    // clic su carta
    for (const r of cardRects) {
      if (pos.x>=r.x && pos.x<=r.x+r.w && pos.y>=r.y && pos.y<=r.y+r.h) {
        if (r.id==="restart") {
          resetGame();
          return;
        }
        state.selectedCard = r.id;
        // subito prova piazzare
        placeSelectedCard();
        return;
      }
    }
  }
}

function placeSelectedCard() {
  const id = state.selectedCard;
  if (!id) return;
  const card = CARDS.find(c=>c.id===id);
  if (!card) return;
  const cost = card.cost;
  if (state.mana < cost) {
    state.notEnoughBlink = 1;
    return;
  }
  state.mana -= cost;
  if (id==="scout" || id==="spark" || id==="tank" || id==="healer") {
    spawnUnit("P",state.selectedLane,id);
  }
}

canvas.addEventListener("mousedown", onPointerDown);
canvas.addEventListener("touchstart", e=>{onPointerDown(e); e.preventDefault();},{passive:false});

/* ============================================================
   13. FUTURO MULTIGIOCATORE (STRUTTURA)
   ============================================================ */
/*
 Per giocare in due con invito, il passo successivo sar√†:
  - aggiungere un backend (Firebase Realtime, Supabase o server Node.js con WebSocket)
  - creare un codice stanza / link (es. ?room=ABC123)
  - sincronizzare:
      - posizionamento delle unit√†
      - stato delle torri, cristallo, mana
  - qui nel client sar√† sufficiente sostituire le funzioni spawnUnit() e resetGame()
    con versioni che inviano/recepiscono eventi dal server.
 Questo file √® gi√† strutturato per poterlo fare senza cambiare la grafica.
*/
</script>
</body>
</html>
