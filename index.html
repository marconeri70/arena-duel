<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Arena Vertical â€“ v2.1</title>
<style>
  html,body{margin:0;height:100%;background:#0f1115;}
  canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;
    touch-action:none; -webkit-tap-highlight-color:transparent;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ===== Canvas & mapping (portrait) ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d',{alpha:false});
const W=720, H=1280, UI_H=200, FIELD_H=H-UI_H;
let scale=1, offX=0, offY=0;
function resize(){
  const r=canvas.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
  canvas.width=Math.max(1,Math.round(r.width*dpr));
  canvas.height=Math.max(1,Math.round(r.height*dpr));
  scale=Math.min(canvas.width/W, canvas.height/H);
  offX=Math.floor((canvas.width-W*scale)/2);
  offY=Math.floor((canvas.height-H*scale)/2);
}
addEventListener('resize',resize); addEventListener('orientationchange',resize); resize();
function toLogical(ev){
  const r=canvas.getBoundingClientRect();
  const X=(ev.clientX-r.left)*(canvas.width/r.width);
  const Y=(ev.clientY-r.top )*(canvas.height/r.height);
  return {x:(X-offX)/scale, y:(Y-offY)/scale};
}

/* ===== Stato ===== */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const COL_X=[W*0.18,W*0.5,W*0.82], RIVER_Y=FIELD_H*0.5;
let selectedCol=1, last=performance.now(), showHelp=false, notEnoughManaBlink=0;

const state={
  mana:5, manaMax:10, manaRegen:0.016,
  time:0, playing:true,
  match:{t:0,len:120},
  crowns:{you:0, enemy:0},
  playerTowers:[{x:W*0.25,y:FIELD_H-95,hp:100,max:100},{x:W*0.75,y:FIELD_H-95,hp:100,max:100}],
  enemyTowers: [{x:W*0.25,y:95,hp:100,max:100},{x:W*0.75,y:95,hp:100,max:100}],
  units:[], floats:[], particles:[]
};

/* ===== SFX minimal ===== */
let ac;
function sfx(kind){
  try{
    ac=ac||new (window.AudioContext||window.webkitAudioContext)();
    const o=ac.createOscillator(), g=ac.createGain();
    const map={hit:[220,.05,'square'], place:[660,.06,'square'], win:[880,.35,'triangle'], lose:[160,.35,'triangle'], heal:[520,.07,'sine']};
    const [f,t,w]=(map[kind]||[440,.08,'square']); o.type=w; o.frequency.value=f; g.gain.value=.06;
    o.connect(g); g.connect(ac.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+t); o.stop(ac.currentTime+t);
  }catch(_){}
}

/* ===== Utility effetti ===== */
function addFloat(x,y,v,c){ state.floats.push({x,y,v,c,t:0}); }
function addHit(x,y,c){ for(let i=0;i<8;i++) state.particles.push({x,y,vx:rand(-1,1),vy:rand(-1.2,-.2),life:rand(.25,.5),t:0,c}); }
function damage(t,d){ if(!('hp'in t))return; t.hp-=d; const c=d>=0?'#ffb36a':'#6afc86'; addFloat(t.x,t.y-24,(d>=0?'-':'+')+Math.abs(d),c); addHit(t.x,t.y-6,c); sfx(d>=0?'hit':'heal'); }
function heal(t,amt){ if(!('hp' in t))return; const before=t.hp; t.hp=Math.min(t.max,t.hp+amt); if(t.hp>before){ addFloat(t.x,t.y-24,'+'+Math.round(t.hp-before),'#6afc86'); sfx('heal'); }}

/* ===== UnitÃ  & IA ===== */
function addUnit(team,col,type){
  const x=COL_X[col], y=(team==='P')?FIELD_H-140:140, dir=(team==='P')?-1:1;
  const u={team,x,y,dir,col,type,cd:0,maxhp:1,hp:1,spd:1,atk:1,range:24,rate:1};
  if(type==='scout') Object.assign(u,{spd:1.2,hp:16,maxhp:16,atk:3,range:22,rate:.5});
  else if(type==='tank') Object.assign(u,{spd:.7,hp:60,maxhp:60,atk:6,range:26,rate:1.0});
  else if(type==='spark') Object.assign(u,{spd:.9,hp:12,maxhp:12,atk:8,range:95,rate:1.2});
  else if(type==='healer') Object.assign(u,{spd:1.0,hp:18,maxhp:18,atk:-6,range:70,rate:1.0}); // negativo = cura
  state.units.push(u); sfx('place');
}
let aiT=2.2;
function ai(dt){
  aiT-=dt;
  if(aiT<=0 && state.playing){
    aiT=rand(1.4,2.6);
    const m=Math.floor(state.mana), pool=[];
    if(m>=2) pool.push('spark'); if(m>=3) pool.push('scout','healer'); if(m>=4) pool.push('tank');
    if(pool.length){
      const tp=pool[(Math.random()*pool.length)|0], c=tp==='tank'?4:tp==='scout'||tp==='healer'?3:2;
      state.mana=Math.max(0,state.mana-c);
      addUnit('E',(Math.random()*3)|0,tp);
    }
  }
}
function nearest(u,towers,foes){
  let best=null,score=1e9;
  for(const f of foes){ const s=Math.abs(f.y*u.dir-u.y*u.dir)+Math.abs(f.x-u.x)*.25; if(s<score){score=s;best=f;} }
  if(!best){ let tg=null,sm=1e9; for(const t of towers){ const s=Math.abs(t.y-u.y)+Math.abs(t.x-u.x)*.3; if(t.hp>0&&s<sm){sm=s; tg=t;} } best=tg; }
  return {t:best, dist:best?Math.hypot(best.x-u.x,best.y-u.y):1e9};
}

/* ===== Update ===== */
function step(dt){
  // timer e mana
  if(state.playing){
    state.match.t+=dt; state.time+=dt;
    if(state.match.t>=state.match.len){ state.playing=false; sfx('lose'); }
    state.mana=clamp(state.mana+state.manaRegen*60*dt,0,state.manaMax);
    ai(dt);
  }
  // unitÃ 
  for(const u of state.units){
    const enemy = u.team==='P'?'E':'P';
    const foes  = state.units.filter(x=>x.team===enemy && x.col===u.col);
    const allies= state.units.filter(x=>x.team===u.team && x.col===u.col);
    const towers=(enemy==='E'?state.enemyTowers:state.playerTowers).filter(t=>Math.abs(t.x-u.x)<W*0.35);
    const allyT  =(u.team==='P'?state.playerTowers:state.enemyTowers).filter(t=>Math.abs(t.x-u.x)<W*0.35);

    u.cd-=dt;

    if(u.type==='healer'){
      // cura l'alleato piÃ¹ vicino (unitÃ  o torre) nella corsia
      let target=null, dist=1e9;
      for(const a of allies){ const d=Math.hypot(a.x-u.x,a.y-u.y); if(a.hp<a.maxhp && d<dist){dist=d; target=a;} }
      for(const t of allyT){ const d=Math.hypot(t.x-u.x,t.y-u.y); if(t.hp<t.max && d<dist){dist=d; target=t;} }
      if(target && dist<=u.range){ if(u.cd<=0){ u.cd=u.rate; if('max' in target) heal(target, Math.abs(u.atk)); else heal(target, Math.abs(u.atk)); } }
      else u.y += u.spd*u.dir*60*dt;
    }else{
      // attacca
      const {t, dist} = nearest(u, towers, foes);
      if(t && dist<=u.range){ if(u.cd<=0){u.cd=u.rate; if('max' in t) damage(t,u.atk); else damage(t,u.atk);} }
      else u.y += u.spd*u.dir*60*dt;
    }
  }
  // pulizia
  state.units=state.units.filter(u=>u.hp>0 && u.y>40 && u.y<FIELD_H-40);
  for(const f of state.floats){ f.t+=dt; f.y-=24*dt; } state.floats=state.floats.filter(f=>f.t<.9);
  for(const p of state.particles){ p.t+=dt; p.x+=p.vx*60*dt; p.y+=p.vy*60*dt; p.vy+=.04; } state.particles=state.particles.filter(p=>p.t<p.life);

  // corone + fine partita
  const pAlive=state.playerTowers.filter(t=>t.hp>0).length;
  const eAlive=state.enemyTowers.filter(t=>t.hp>0).length;
  state.crowns.you   = 2 - eAlive;
  state.crowns.enemy = 2 - pAlive;
  if(state.playing && (pAlive===0 || eAlive===0)){ state.playing=false; sfx(eAlive===0?'win':'lose'); }
}

/* ===== Draw ===== */
function bg(){
  const g=ctx.createLinearGradient(0,0,0,FIELD_H);
  g.addColorStop(0,'#efe7be'); g.addColorStop(1,'#d9cf98');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,FIELD_H);

  ctx.strokeStyle='#00000012'; ctx.lineWidth=1; ctx.beginPath();
  for(let y=0;y<=FIELD_H;y+=64){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  for(let x=0;x<=W;x+=80){ ctx.moveTo(x,0); ctx.lineTo(x,FIELD_H); }
  ctx.stroke();

  ctx.strokeStyle='#b9b083'; ctx.lineWidth=2; for(const x of COL_X){ ctx.beginPath(); ctx.moveTo(x,20); ctx.lineTo(x,FIELD_H-20); ctx.stroke(); }

  const rgrad=ctx.createLinearGradient(0,RIVER_Y-14,0,RIVER_Y+14);
  rgrad.addColorStop(0,'#9adcf0'); rgrad.addColorStop(.5,'#7bc6de'); rgrad.addColorStop(1,'#64b7d4');
  ctx.fillStyle=rgrad; ctx.fillRect(0,RIVER_Y-14,W,28);

  const bridge=cx=>{ ctx.save(); ctx.translate(cx,RIVER_Y);
    ctx.fillStyle='#0000002a'; ctx.beginPath(); ctx.ellipse(0,14,64,10,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#8c5a2c'; ctx.strokeStyle='#5e3c1c'; ctx.lineWidth=3; ctx.fillRect(-64,-18,128,36); ctx.strokeRect(-64,-18,128,36);
    ctx.strokeStyle='#6d461f'; for(let i=-58;i<=58;i+=14){ ctx.beginPath(); ctx.moveTo(i,-18); ctx.lineTo(i,18); ctx.stroke(); } ctx.restore(); };
  bridge(W*0.3); bridge(W*0.7);

  // evidenzia corsia selezionata
  ctx.fillStyle='#1a7fff18'; ctx.fillRect(COL_X[selectedCol]-W*0.16, 0, W*0.32, FIELD_H);
}
function tower(t,friendly){
  ctx.fillStyle='#00000022'; ctx.beginPath(); ctx.ellipse(t.x,t.y+12,28,9,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#b9c2cc'; ctx.strokeStyle='#8b97a5'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(t.x,t.y,26,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle=friendly?'#3b7ae0':'#d14f4f'; ctx.beginPath(); ctx.arc(t.x,t.y,20,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#f4cd63'; ctx.strokeStyle='#9a7b1a';
  ctx.beginPath(); ctx.moveTo(t.x-15,t.y-20); ctx.lineTo(t.x-5,t.y-6); ctx.lineTo(t.x+5,t.y-20); ctx.lineTo(t.x+15,t.y-6); ctx.lineTo(t.x+15,t.y-2); ctx.lineTo(t.x-15,t.y-2); ctx.closePath(); ctx.fill(); ctx.stroke();
  const sway=Math.sin(state.time*2+t.x)*3; ctx.fillStyle=friendly?'#6fe0ff':'#ffd46f';
  ctx.beginPath(); ctx.moveTo(t.x+20,t.y-10); ctx.lineTo(t.x+20+16+sway,t.y-16); ctx.lineTo(t.x+20,t.y-22); ctx.closePath(); ctx.fill();
  const w=72,h=8; ctx.fillStyle='#00000055'; ctx.fillRect(t.x-w/2,t.y-36,w,h);
  ctx.fillStyle='#4ee46a'; ctx.fillRect(t.x-w/2,t.y-36,w*clamp(t.hp/t.max,0,1),h);
}
function drawUnit(u){
  ctx.fillStyle='#00000025'; ctx.beginPath(); ctx.ellipse(u.x,u.y+8,16,6,0,0,Math.PI*2); ctx.fill();
  if(u.team==='P'){ ctx.strokeStyle='#0b4ea2'; ctx.fillStyle='#2f80ed'; } else { ctx.strokeStyle='#9b1c1c'; ctx.fillStyle='#eb5757'; }
  ctx.lineWidth=2;
  if(u.type==='tank'){ ctx.fillRect(u.x-16,u.y-12,32,24); ctx.strokeRect(u.x-16,u.y-12,32,24); }
  else if(u.type==='scout'){ ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  else if(u.type==='spark'){ const grd=ctx.createRadialGradient(u.x,u.y,2,u.x,u.y,16);
    grd.addColorStop(0,'#fffacd'); grd.addColorStop(1,(u.team==='P')?'#2f80ed':'#eb5757'); ctx.fillStyle=grd;
    ctx.beginPath(); ctx.moveTo(u.x-14,u.y+10); ctx.lineTo(u.x+14,u.y+10); ctx.lineTo(u.x,u.y-12); ctx.closePath(); ctx.fill(); ctx.strokeStyle=(u.team==='P')?'#0b4ea2':'#9b1c1c'; ctx.stroke();
  }else{ // healer
    ctx.fillStyle='#7cd37c'; ctx.strokeStyle='#2d7a2d';
    ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#2d7a2d'; ctx.fillRect(u.x-2,u.y-8,4,16); ctx.fillRect(u.x-8,u.y-2,16,4);
  }
  ctx.fillStyle='#00000055'; ctx.fillRect(u.x-12,u.y-20,24,4);
  ctx.fillStyle='#4ee46a'; ctx.fillRect(u.x-12,u.y-20,24*clamp(u.hp/u.maxhp,0,1),4);
}
function drawCrowns(){
  ctx.fillStyle='#0f1115aa'; ctx.fillRect(0,0,W,22);
  ctx.font='bold 14px system-ui'; ctx.textAlign='left'; ctx.fillStyle='#ffd966';
  ctx.fillText('ðŸ”± '+state.crowns.you, 10, 16);
  ctx.textAlign='right'; ctx.fillText(state.crowns.enemy+' ðŸ”±', W-10, 16);
}
const cards=[
  {label:'Scout (3)', type:'scout', cost:3},
  {label:'Tank (4)',  type:'tank',  cost:4},
  {label:'Spark (2)', type:'spark', cost:2},
  {label:'Healer (3)',type:'healer',cost:3},
  {label:'Riavvia',   type:'restart', cost:0},
];
const cardRects=[];
function drawUI(){
  // pannello
  ctx.fillStyle='#0f1115'; ctx.fillRect(0,FIELD_H,W,UI_H);
  // help button
  helpBtn={x:W-44,y:FIELD_H+12,w:32,h:32};
  ctx.fillStyle='#1b2330'; ctx.strokeStyle='#2c3c54'; ctx.lineWidth=2; roundRect(helpBtn.x,helpBtn.y,helpBtn.w,helpBtn.h,8,true,true);
  ctx.fillStyle='#eef'; ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('?',helpBtn.x+helpBtn.w/2,helpBtn.y+helpBtn.h/2+1);

  // mana
  ctx.fillStyle='#202a3a'; ctx.fillRect(24, FIELD_H+16, W-48, 14);
  ctx.fillStyle='#61dafb'; ctx.fillRect(24, FIELD_H+16, (W-48)*(state.mana/state.manaMax), 14);

  // bottoni
  cardRects.length=0; const gap=14, h=70, y=FIELD_H+44;
  const w=(W-48-gap*(cards.length-1))/cards.length; let x=24;
  ctx.font='600 16px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const c of cards){
    const ok = c.type==='restart' || (state.mana>=c.cost && state.playing);
    const blink = (!ok && notEnoughManaBlink>0);
    ctx.fillStyle = ok ? '#1b2330' : (blink ? '#44222a' : '#121821');
    ctx.strokeStyle='#2c3c54'; ctx.lineWidth=2; roundRect(x,y,w,h,14,true,true);
    ctx.fillStyle = ok ? '#eef' : '#8b96aa'; ctx.fillText(c.label, x+w/2, y+h/2);
    cardRects.push({x,y,w,h,...c});
    x+=w+gap;
  }

  // overlay fine partita
  if(!state.playing){
    ctx.fillStyle='#00000080'; ctx.fillRect(0,0,W,FIELD_H);
    ctx.fillStyle='#fff'; ctx.font='bold 38px system-ui'; ctx.textAlign='center';
    const win = state.crowns.you>state.crowns.enemy || state.enemyTowers.every(t=>t.hp<=0);
    ctx.fillText(win?'ðŸ† Vittoria!':'ðŸ’€ Sconfitta', W/2, FIELD_H/2);
    ctx.font='18px system-ui'; ctx.fillText('Tocca "Riavvia" per giocare ancora', W/2, FIELD_H/2+40);
  }

  // help overlay
  if(showHelp){
    ctx.fillStyle='#000000cc'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.font='bold 26px system-ui'; ctx.textAlign='center';
    ctx.fillText('Guida rapida', W/2, 120);
    ctx.font='18px system-ui'; ctx.textAlign='left';
    const tY=160, lh=26, x0=60;
    const lines=[
      'â€¢ Tocca il CAMPO per scegliere la corsia (A/B/C).',
      'â€¢ Gioca una carta per calarla nella corsia selezionata.',
      'â€¢ Il numero tra parentesi Ã¨ il COSTO in mana.',
      'â€¢ Healer (3) cura unitÃ  e torri alleate della corsia.',
      'â€¢ Distruggi le torri nemiche per guadagnare ðŸ”± corone.',
      'â€¢ Vince chi ha piÃ¹ corone o chi abbatte entrambe le torri.',
      'â€¢ â€œRiavviaâ€ ricomincia la partita (e il timer).'
    ];
    let y=tY; for(const s of lines){ ctx.fillText(s, x0, y); y+=lh; }
    // bottone chiudi
    const bx=W/2-80, by=y+20, bw=160, bh=48;
    roundRect(bx,by,bw,bh,12,true,true);
    ctx.fillStyle='#1b2330'; ctx.fillRect(bx,by,bw,bh); ctx.strokeStyle='#2c3c54'; ctx.lineWidth=2; roundRect(bx,by,bw,bh,12,false,true);
    ctx.fillStyle='#eef'; ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('Chiudi', bx+bw/2, by+bh/2);
    helpClose={x:bx,y:by,w:bw,h:bh};
  } else helpClose=null;
}
function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

/* ===== Loop ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#0f1115'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offX,offY);
  bg(); drawCrowns();
  state.playerTowers.forEach(t=>tower(t,true));
  state.enemyTowers.forEach(t=>tower(t,false));
  for(const u of state.units) drawUnit(u);
  for(const f of state.floats){ const a=1-f.t/.9; ctx.globalAlpha=a; ctx.fillStyle=f.c; ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.fillText(f.v,f.x,f.y); ctx.globalAlpha=1; }
  for(const p of state.particles){ const a=1-p.t/p.life; ctx.globalAlpha=a; ctx.fillStyle=p.c; ctx.fillRect(p.x-2,p.y-2,4,4); ctx.globalAlpha=1; }
  drawUI();
}
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  step(dt); if(notEnoughManaBlink>0) notEnoughManaBlink-=dt;
  draw(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Input ===== */
let helpBtn=null, helpClose=null;
canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  const {x,y}=toLogical(e);

  // Campo â†’ selezione corsia
  if(y<FIELD_H && !showHelp){
    let k=0,b=1e9; for(let i=0;i<COL_X.length;i++){ const d=Math.abs(x-COL_X[i]); if(d<b){b=d;k=i;} }
    selectedCol=k; return;
  }
  // Help
  if(helpBtn && x>=helpBtn.x && x<=helpBtn.x+helpBtn.w && y>=helpBtn.y && y<=helpBtn.y+helpBtn.h){ showHelp=!showHelp; return; }
  if(showHelp && helpClose && x>=helpClose.x && x<=helpClose.x+helpClose.w && y>=helpClose.y && y<=helpClose.y+helpClose.h){ showHelp=false; return; }

  // Carte
  for(const r of cardRects){
    if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
      if(r.type==='restart'){
        state.playing=true; state.mana=5; state.units.length=0; state.time=0; state.match.t=0; state.crowns.you=state.crowns.enemy=0;
        state.playerTowers.forEach(t=>t.hp=t.max); state.enemyTowers.forEach(t=>t.hp=t.max); return;
      }
      if(state.playing && state.mana>=r.cost){ addUnit('P', selectedCol??1, r.type); state.mana=Math.max(0,state.mana-r.cost); }
      else { notEnoughManaBlink=.25; } // feedback
      return;
    }
  }
},{passive:false});
</script>
</body>
</html>
