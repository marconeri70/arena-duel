<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Arena Duel – v3 (Xiaomi/Chrome fix)</title>
<style>
  html,body{margin:0;height:100%;background:#0e1013;}
  canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block; touch-action:none; -webkit-tap-highlight-color:transparent;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ====== Canvas fullscreen con trasformazione controllata ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});

let cssW=0, cssH=0, pxW=0, pxH=0;  // dimensioni canvas
const W=720, H=1280;               // spazio logico in verticale
const PLAY_H=1080, UI_H=H-PLAY_H;

let scale=1, offX=0, offY=0;       // trasformazione attuale (in pixel canvas)

/* aggiorna dimensioni e trasformazione */
function resize(){
  const r = canvas.getBoundingClientRect();
  cssW = r.width; cssH = r.height;
  const dpr = window.devicePixelRatio || 1;
  pxW = Math.max(1, Math.round(cssW*dpr));
  pxH = Math.max(1, Math.round(cssH*dpr));
  if(canvas.width!==pxW || canvas.height!==pxH){ canvas.width=pxW; canvas.height=pxH; }
  // mappa W×H dentro pxW×pxH (letterboxing)
  scale = Math.min(pxW / W, pxH / H);
  offX  = Math.floor((pxW - W*scale)/2);
  offY  = Math.floor((pxH - H*scale)/2);
}
addEventListener('resize', resize);
addEventListener('orientationchange', resize);
resize();

/* funzione INVERTI trasformazione: da evento → coordinate logiche */
function toLogical(ev){
  // coord in CSS pixel dentro il canvas
  const rect = canvas.getBoundingClientRect();
  const cssX = ev.clientX - rect.left;
  const cssY = ev.clientY - rect.top;
  // CSS → pixel canvas
  const Xd = cssX * (canvas.width / rect.width);
  const Yd = cssY * (canvas.height / rect.height);
  // pixel canvas → coordinate logiche (invertiamo Xd = offX + scale*Xl)
  const Xl = (Xd - offX) / scale;
  const Yl = (Yd - offY) / scale;
  return {x:Xl, y:Yl};
}

/* ====== Gioco (uguale a prima) ====== */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
let tprev=performance.now(), playing=true;
const LANE_Y=[PLAY_H*0.58, PLAY_H*0.70, PLAY_H*0.82];
const RIVER_Y=PLAY_H*0.56;

const state={
  mana:5, manaMax:10, manaRegen:0.015, t:0, time:0,
  playerTowers:[{x:W*0.12,y:PLAY_H*0.60,hp:100,max:100},{x:W*0.12,y:PLAY_H*0.80,hp:100,max:100}],
  enemyTowers:[{x:W*0.88,y:PLAY_H*0.60,hp:100,max:100},{x:W*0.88,y:PLAY_H*0.80,hp:100,max:100}],
  units:[], floats:[], particles:[]
};

function addUnit(team,lane,type){
  const y=LANE_Y[lane], dir=(team==='P')?1:-1, x=(team==='P')?W*0.20:W*0.80;
  const u={team,x,y,dir,type,cd:0};
  if(type==='scout') Object.assign(u,{spd:.8,hp:18,atk:3,range:14,rate:.7});
  else if(type==='tank') Object.assign(u,{spd:.45,hp:60,atk:6,range:18,rate:1.2});
  else Object.assign(u,{spd:.7,hp:12,atk:8,range:70,rate:1.6}); // spark
  state.units.push(u);
}

let aiTimer=2.5;
function ai(dt){
  aiTimer-=dt;
  if(aiTimer<=0 && playing){
    aiTimer = rand(1.8,3.2);
    const m=Math.floor(state.mana), opt=[];
    if(m>=2) opt.push('spark'); if(m>=3) opt.push('scout'); if(m>=4) opt.push('tank');
    if(opt.length){ const t=opt[(Math.random()*opt.length)|0], c=(t==='tank'?4:(t==='scout'?3:2));
      state.mana=Math.max(0,state.mana-c); addUnit('E',(Math.random()*3)|0,t); }
  }
}

function addFloat(x,y,v,col){ state.floats.push({x,y,v,col,t:0}); }
function addHitSparks(x,y,col){ for(let i=0;i<8;i++) state.particles.push({x,y,vx:rand(-1,1),vy:rand(-1.5,-0.4),life:rand(.3,.6),t:0,col}); }
function applyDamage(t,d){ if(!('hp' in t))return; t.hp-=d; const c=d>=0?'#ffb36a':'#6afc86'; addFloat(t.x,t.y-26,(d>=0?'-':'+')+Math.abs(d),c); addHitSparks(t.x,t.y-10,c); }
function nearest(u,towers,foes){
  let best=null,bd=1e9;
  for(const f of foes){ const d=Math.hypot(f.x*u.dir-u.x*u.dir,f.y-u.y); if(d<bd){bd=d; best=f;} }
  if(!best){ let tgt=null,dm=1e9; for(const t of towers){ const d=Math.abs(t.y-u.y)+Math.abs(t.x-u.x); if(t.hp>0&&d<dm){dm=d; tgt=t;} } best=tgt; }
  return {t:best,d:best?Math.hypot(best.x-u.x,best.y-u.y):1e9};
}

function step(dt){
  if(!playing) return;
  state.t+=dt; state.time+=dt;
  state.mana = clamp(state.mana + (state.manaRegen+0.003*Math.sin(state.t*2.2))*60*dt, 0, state.manaMax);
  ai(dt);

  for(const u of state.units){
    const enemy=u.team==='P'?'E':'P';
    const foes=state.units.filter(x=>x.team===enemy);
    const towers=(enemy==='E'?state.enemyTowers:state.playerTowers);
    const {t,d}=nearest(u,towers,foes);
    u.cd-=dt;
    if(t && d<=u.range){ if(u.cd<=0){ u.cd=u.rate; applyDamage(t,u.atk); } }
    else u.x += u.spd*u.dir*60*dt;
  }

  for(const f of state.floats){ f.t+=dt; f.y-=20*dt; f.x+=Math.sin(f.t*6)*6*dt; }
  state.floats=state.floats.filter(f=>f.t<.9);
  for(const p of state.particles){ p.t+=dt; p.x+=p.vx*60*dt; p.y+=p.vy*60*dt; p.vy+=.03; }
  state.particles=state.particles.filter(p=>p.t<p.life);
  state.units=state.units.filter(u=>u.hp>0 && u.x>0 && u.x<W);

  const pAlive=state.playerTowers.some(t=>t.hp>0), eAlive=state.enemyTowers.some(t=>t.hp>0);
  if(!pAlive || !eAlive) playing=false;
}

/* ====== Disegno ====== */
const CARDS=[
  {label:'Scout (3)', type:'scout', cost:3},
  {label:'Tank (4)',  type:'tank',  cost:4},
  {label:'Spark (2)', type:'spark', cost:2},
  {label:'Riavvia',   type:'restart', cost:0}
];
const cardRects=[]; // hitbox dei pulsanti

function drawBG(){
  const g=ctx.createLinearGradient(0,0,0,PLAY_H); g.addColorStop(0,'#efe7be'); g.addColorStop(1,'#dbcf9a');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,PLAY_H);

  ctx.strokeStyle='#b9b083'; ctx.lineWidth=2;
  [PLAY_H*0.58,PLAY_H*0.70,PLAY_H*0.82].forEach(y=>{ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); });

  ctx.fillStyle='#7ccbe1'; ctx.fillRect(0,PLAY_H*0.52,W,12);

  const bridge=cx=>{ ctx.save(); ctx.translate(cx,PLAY_H*0.52+6);
    ctx.fillStyle='#8c5a2c'; ctx.strokeStyle='#5e3c1c'; ctx.lineWidth=3;
    ctx.fillRect(-40,-12,80,24); ctx.strokeRect(-40,-12,80,24);
    ctx.strokeStyle='#75471f'; for(let i=-36;i<=36;i+=12){ ctx.beginPath(); ctx.moveTo(i,-12); ctx.lineTo(i,12); ctx.stroke(); } ctx.restore(); };
  bridge(W*.3); bridge(W*.7);
}
function drawTower(t,friend){
  ctx.fillStyle='#00000020'; ctx.beginPath(); ctx.ellipse(t.x,t.y+10,26,10,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=friend?'#4b6cb7':'#c24b4b'; ctx.strokeStyle=friend?'#0e3f8f':'#8a1f1f'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(t.x,t.y,24,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#f2d16b'; ctx.strokeStyle='#a8841e';
  ctx.beginPath(); ctx.moveTo(t.x-14,t.y-20); ctx.lineTo(t.x-7,t.y-10); ctx.lineTo(t.x,t.y-20); ctx.lineTo(t.x+7,t.y-10); ctx.lineTo(t.x+14,t.y-20); ctx.lineTo(t.x+14,t.y-8); ctx.lineTo(t.x-14,t.y-8); ctx.closePath(); ctx.fill(); ctx.stroke();
  const w=70,h=8; ctx.fillStyle='#00000055'; ctx.fillRect(t.x-w/2,t.y-34,w,h);
  ctx.fillStyle='#4ee46a'; ctx.fillRect(t.x-w/2,t.y-34,w*clamp(t.hp/t.max,0,1),h);
}
function drawUnits(){
  for(const u of state.units){
    ctx.fillStyle='#00000020'; ctx.beginPath(); ctx.ellipse(u.x,u.y+8,16,7,0,0,Math.PI*2); ctx.fill();
    if(u.team==='P'){ ctx.fillStyle='#2f80ed'; ctx.strokeStyle='#0b4ea2'; } else { ctx.fillStyle='#eb5757'; ctx.strokeStyle='#9b1c1c'; }
    ctx.lineWidth=2;
    if(u.type==='tank'){ ctx.fillRect(u.x-16,u.y-12,32,24); ctx.strokeRect(u.x-16,u.y-12,32,24); }
    else if(u.type==='scout'){ ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
    else { ctx.beginPath(); ctx.moveTo(u.x-14,u.y+10); ctx.lineTo(u.x+14,u.y+10); ctx.lineTo(u.x,u.y-12); ctx.closePath(); ctx.fill(); ctx.stroke(); }
    ctx.fillStyle='#00000055'; ctx.fillRect(u.x-12,u.y-20,24,4);
    const maxhp=u.type==='tank'?60:u.type==='scout'?18:12; ctx.fillStyle='#4ee46a'; ctx.fillRect(u.x-12,u.y-20,24*clamp(u.hp/maxhp,0,1),4);
  }
}
function drawUI(){
  // fascia scura
  ctx.fillStyle='#0e1013'; ctx.fillRect(0,PLAY_H,W,UI_H);

  // mana bar
  ctx.fillStyle='#22324a'; ctx.fillRect(16, PLAY_H+8, W-32, 12);
  ctx.fillStyle='#61dafb'; ctx.fillRect(16, PLAY_H+8, (W-32)*(state.mana/state.manaMax), 12);

  // pulsanti
  cardRects.length=0;
  const gap=12, w=(W-32-gap*(CARDS.length-1))/CARDS.length, h=52, y=PLAY_H+24; let x=16;
  ctx.font='16px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const c of CARDS){
    ctx.fillStyle='#1b2330'; ctx.strokeStyle='#2c3c54'; ctx.lineWidth=2; ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
    ctx.fillStyle='#eef'; ctx.fillText(c.label, x+w/2, y+h/2);
    cardRects.push({x:x-6, y:y-6, w:w+12, h:h+12, ...c}); // hitbox più ampia
    x+=w+gap;
  }
}
function draw(){
  // letterbox
  ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#0e1013'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // area logica
  ctx.setTransform(scale,0,0,scale,offX,offY);
  drawBG();
  state.playerTowers.forEach(t=>drawTower(t,true));
  state.enemyTowers.forEach(t=>drawTower(t,false));
  drawUnits();
  // (danni/cure/particelle omessi per semplicità)
  drawUI();
}

function loop(now){
  const dt=Math.min(0.033,(now-tprev)/1000);
  tprev=now; step(dt); draw(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== Pointer Events: un solo handler per tap/click ====== */
canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  // coord logiche
  const {x,y} = toLogical(e);
  // test sui bottoni
  for(const r of cardRects){
    if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
      if(r.type==='restart'){
        state.units.length=0; state.mana=5; state.t=0; state.time=0; playing=true;
        state.playerTowers.forEach(t=>t.hp=t.max); state.enemyTowers.forEach(t=>t.hp=t.max);
      }else if(playing && state.mana>=r.cost){
        const lane = Math.floor(state.time*2) % 3;
        addUnit('P', lane, r.type);
        state.mana -= r.cost;
      }
      return;
    }
  }
}, {passive:false});
</script>
</body>
</html>
