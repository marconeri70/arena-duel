<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <title>Arena Duel ‚Äì Proto pulito</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="theme-color" content="#05070b">
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    html,body{
      margin:0;
      padding:0;
      height:100%;
      background:#05070b;
      color:#fff;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      overscroll-behavior:none;
      touch-action:none;
    }
    body{
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    canvas{
      flex:1;
      display:block;
      width:100%;
      height:100%;
      touch-action:none;
      -webkit-tap-highlight-color:transparent;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ===================== Costanti logiche =====================
const LOGICAL_W = 720;
const LOGICAL_H = 1280;
const UI_H      = 180;
const FIELD_H   = LOGICAL_H - UI_H;
const LANES_X   = [LOGICAL_W * 0.2, LOGICAL_W * 0.5, LOGICAL_W * 0.8];
const RIVER_Y   = FIELD_H * 0.5;

const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d', { alpha:false });

let scale = 1, offX = 0, offY = 0;

// ===================== Resize & mapping =====================
function resize() {
  const rect = canvas.getBoundingClientRect();
  const dpr  = window.devicePixelRatio || 1;
  canvas.width  = Math.max(1, Math.round(rect.width  * dpr));
  canvas.height = Math.max(1, Math.round(rect.height * dpr));

  scale = Math.min(canvas.width / LOGICAL_W, canvas.height / LOGICAL_H);
  offX  = Math.round((canvas.width  - LOGICAL_W * scale) / 2);
  offY  = Math.round((canvas.height - LOGICAL_H * scale) / 2);
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);
resize();

function toGameCoords(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const px = (clientX - rect.left) * (canvas.width  / rect.width);
  const py = (clientY - rect.top)  * (canvas.height / rect.height);
  return {
    x: (px - offX) / scale,
    y: (py - offY) / scale
  };
}

// ===================== Stato di gioco =====================
const CARDS = [
  { key:'scout',  label:'Scout',  cost:3, color:'#4fc3f7' },
  { key:'spark',  label:'Spark',  cost:2, color:'#ffe082' },
  { key:'tank',   label:'Tank',   cost:4, color:'#ffab91' },
  { key:'healer', label:'Healer', cost:3, color:'#a5d6a7' },
  { key:'reset',  label:'Riavvia',cost:0, color:'#cfd8dc' }
];

let cardRects = [];
let selectedLane = 1;
let manaFlash = 0;

const state = {
  playing: true,
  time: 0,
  mana: 5,
  manaMax: 10,
  manaRegen: 1.2, // al secondo
  enemyMana: 5,
  enemyManaRegen: 1.0,
  crownsYou: 0,
  crownsEnemy: 0,
  playerTowers: [
    { x: LOGICAL_W*0.25, y: FIELD_H-110, hp:100, maxHp:100 },
    { x: LOGICAL_W*0.75, y: FIELD_H-110, hp:100, maxHp:100 }
  ],
  enemyTowers: [
    { x: LOGICAL_W*0.25, y: 110, hp:100, maxHp:100 },
    { x: LOGICAL_W*0.75, y: 110, hp:100, maxHp:100 }
  ],
  units: [],     // {team:'player'|'enemy', lane, x,y,dir, type, hp,maxHp,atk,range,spd,cooldown,rate}
  projectiles: [], // {team, x,y,vx,vy,damage,heal,life,colorA,colorB}
  manaCrystal: {
    x: LOGICAL_W * 0.5,
    y: RIVER_Y,
    hp: 40,
    maxHp: 40,
    alive: true,
    lastHitBy: null // 'player' o 'enemy'
  }
};

// ===================== Utilit√† =====================
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function spawnUnit(team, laneIndex, key){
  const laneX = LANES_X[laneIndex];
  const dir   = (team === 'player') ? -1 : 1;
  const y0    = (team === 'player') ? (FIELD_H - 160) : 160;

  const base = {
    team,
    lane: laneIndex,
    x: laneX,
    y: y0,
    dir,
    cooldown: 0,
    rate: 1.0,
    range: 32,
    hp: 20,
    maxHp: 20,
    atk: 4,
    spd: 60,
    type: key
  };

  if(key === 'scout'){
    base.spd = 80; base.hp = base.maxHp = 18; base.atk = 3; base.range = 26; base.rate = 0.7;
  }else if(key === 'spark'){
    base.spd = 55; base.hp = base.maxHp = 14; base.atk = 7; base.range = 110; base.rate = 0.9;
  }else if(key === 'tank'){
    base.spd = 40; base.hp = base.maxHp = 60; base.atk = 6; base.range = 30; base.rate = 1.2;
  }else if(key === 'healer'){
    base.spd = 60; base.hp = base.maxHp = 18; base.atk = -6; base.range = 90; base.rate = 1.0;
  }

  state.units.push(base);
}

function launchProjectile(from, target, opts){
  const dx = target.x - from.x;
  const dy = target.y - from.y;
  const dist = Math.hypot(dx, dy) || 1;
  const speed = opts.speed || 260;
  state.projectiles.push({
    team: opts.team,
    x: from.x,
    y: from.y,
    vx: dx / dist * speed,
    vy: dy / dist * speed,
    damage: opts.damage || 0,
    heal: opts.heal || 0,
    life: 1.2,
    colorA: opts.colorA || '#ffffff',
    colorB: opts.colorB || '#81d4fa'
  });
}

// ===================== Input =====================
function onPointerStart(ev){
  ev.preventDefault();
  const touch = ev.touches ? ev.touches[0] : ev;
  const pos = toGameCoords(touch.clientX, touch.clientY);
  if(isNaN(pos.x) || isNaN(pos.y)) return;

  if(pos.y < 0 || pos.y > LOGICAL_H) return;

  if(pos.y < FIELD_H){
    // Seleziona corsia
    let best = 0, bestD = Infinity;
    for(let i=0;i<LANES_X.length;i++){
      const d = Math.abs(pos.x - LANES_X[i]);
      if(d < bestD){ bestD = d; best = i; }
    }
    selectedLane = best;
  } else {
    // Tocca le carte
    for(let i=0;i<cardRects.length;i++){
      const r = cardRects[i];
      if(pos.x >= r.x && pos.x <= r.x+r.w && pos.y >= r.y && pos.y <= r.y+r.h){
        handleCardClick(i);
        break;
      }
    }
  }
}

canvas.addEventListener('mousedown', onPointerStart);
canvas.addEventListener('touchstart', onPointerStart, { passive:false });

function handleCardClick(index){
  const card = CARDS[index];
  if(!card) return;

  if(card.key === 'reset'){
    resetMatch();
    return;
  }

  if(!state.playing) return;

  if(state.mana < card.cost){
    manaFlash = 0.4;
    return;
  }

  state.mana -= card.cost;
  spawnUnit('player', selectedLane, card.key);
}

// ===================== AI semplice =====================
let aiTimer = 2.0;
function enemyAI(dt){
  if(!state.playing) return;
  aiTimer -= dt;
  if(aiTimer > 0) return;
  aiTimer = 1.6 + Math.random()*1.6;

  // sceglie una carta che pu√≤ permettersi
  const affordable = CARDS.filter(c => c.key!=='reset' && state.enemyMana >= c.cost);
  if(!affordable.length) return;
  const card = affordable[Math.floor(Math.random()*affordable.length)];
  const lane = Math.floor(Math.random()*LANES_X.length);
  state.enemyMana -= card.cost;
  spawnUnit('enemy', lane, card.key);
}

// ===================== Update logica =====================
function update(dt){
  state.time += dt;

  if(state.playing){
    state.mana      = clamp(state.mana      + state.manaRegen      * dt, 0, state.manaMax);
    state.enemyMana = clamp(state.enemyMana + state.enemyManaRegen * dt, 0, state.manaMax);
    enemyAI(dt);
  }

  if(manaFlash > 0) manaFlash -= dt;

  // Unit√†
  const units = state.units;
  const pTowers = state.playerTowers;
  const eTowers = state.enemyTowers;

  for(const u of units){
    if(!state.playing) continue;
    u.cooldown -= dt;

    const enemyTeam = (u.team === 'player') ? 'enemy' : 'player';
    const forwardSign = (u.team === 'player') ? -1 : 1;

    // possibili bersagli sulla stessa corsia: altre unit√† + torri nemiche + cristallo centrale
    const foes = [];
    for(const v of units){
      if(v.team !== enemyTeam) continue;
      if(v.lane !== u.lane) continue;
      foes.push(v);
    }
    const towers = (enemyTeam === 'enemy' ? eTowers : pTowers);
    for(const t of towers){
      foes.push(t);
    }
    if(state.manaCrystal.alive && u.lane === 1){
      foes.push(state.manaCrystal);
    }

    // trova bersaglio pi√π vicino in avanti
    let target = null;
    let bestDist = Infinity;
    for(const f of foes){
      const dy = (f.y - u.y) * forwardSign;
      if(dy <= -8) continue; // dietro di lui
      const dx = Math.abs(f.x - u.x);
      const dist = Math.hypot(dx, dy);
      if(dist < bestDist){
        bestDist = dist;
        target = f;
      }
    }

    if(target && bestDist <= u.range){
      // attacco
      if(u.cooldown <= 0){
        u.cooldown = u.rate;
        if(u.type === 'spark' || u.type === 'healer'){
          // attacco a distanza / cura
          const heal = u.atk < 0 ? -u.atk : 0;
          const dmg  = u.atk > 0 ?  u.atk : 0;
          launchProjectile(u, target, {
            team: u.team,
            damage: dmg,
            heal: heal,
            colorA: (heal>0?'#a5d6a7':'#fff59d'),
            colorB: (u.team==='player'?'#81d4fa':'#ffab91'),
            speed: 320
          });
        } else {
          // melee: danno diretto
          applyDamage(target, u.atk, u.team);
        }
      }
    } else if(state.playing) {
      // movimento
      u.y += u.spd * u.dir * dt;
    }
  }

  // proiettili
  for(const p of state.projectiles){
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    if(p.life <= 0) continue;

    const enemyTeam = (p.team === 'player') ? 'enemy' : 'player';

    // collisione con unit√†
    let hit = null;
    for(const u of units){
      if((p.heal > 0 && u.team === p.team) || (p.damage > 0 && u.team === enemyTeam)){
        const d = Math.hypot(u.x - p.x, u.y - p.y);
        if(d < 18){
          hit = u; break;
        }
      }
    }
    if(!hit){
      // collisione con torri / cristallo
      const towerList = (p.damage > 0)
        ? (enemyTeam === 'enemy' ? eTowers : pTowers)
        : (p.team === 'player' ? pTowers : eTowers);
      for(const t of towerList){
        const d = Math.hypot(t.x - p.x, t.y - p.y);
        if(d < 24){ hit = t; break; }
      }
      if(!hit && state.manaCrystal.alive){
        const d = Math.hypot(state.manaCrystal.x - p.x, state.manaCrystal.y - p.y);
        if(d < 28){ hit = state.manaCrystal; }
      }
    }
    if(hit){
      if(p.heal > 0){
        hit.hp = clamp(hit.hp + p.heal, 0, hit.maxHp || 100);
      }
      if(p.damage > 0){
        applyDamage(hit, p.damage, p.team);
      }
      p.life = 0;
    }
  }

  // pulizia
  state.projectiles = state.projectiles.filter(p => p.life > 0);
  state.units = state.units.filter(u => u.hp > 0 && u.y > 20 && u.y < FIELD_H - 20);

  // vittoria/sconfitta
  const pAlive = state.playerTowers.filter(t=>t.hp>0).length;
  const eAlive = state.enemyTowers.filter(t=>t.hp>0).length;
  state.crownsYou   = 2 - eAlive;
  state.crownsEnemy = 2 - pAlive;

  if(state.playing){
    if(eAlive === 0){
      state.playing = false;
      endBanner = 'Vittoria!';
    }else if(pAlive === 0){
      state.playing = false;
      endBanner = 'Sconfitta';
    }
  }
}

// ===================== Danno =====================
function applyDamage(target, dmg, fromTeam){
  if(!target || dmg <= 0) return;
  target.hp = (target.hp || target.maxHp) - dmg;
  if(target === state.manaCrystal){
    state.manaCrystal.lastHitBy = fromTeam;
    if(target.hp <= 0 && target.alive){
      target.alive = false;
      // bonus mana
      if(fromTeam === 'player'){
        state.mana = clamp(state.mana + 5, 0, state.manaMax);
      }else{
        state.enemyMana = clamp(state.enemyMana + 5, 0, state.manaMax);
      }
    }
  }
}

// ===================== Reset partita =====================
let endBanner = '';
function resetMatch(){
  state.playing = true;
  state.time = 0;
  state.mana = 5;
  state.enemyMana = 5;
  state.crownsYou = 0;
  state.crownsEnemy = 0;
  state.units.length = 0;
  state.projectiles.length = 0;
  state.playerTowers.forEach(t=>{ t.hp = t.maxHp; });
  state.enemyTowers.forEach(t=>{ t.hp = t.maxHp; });
  state.manaCrystal.hp = state.manaCrystal.maxHp;
  state.manaCrystal.alive = true;
  state.manaCrystal.lastHitBy = null;
  endBanner = '';
}

// ===================== Rendering =====================
function drawBackground(){
  // campo
  ctx.fillStyle = '#e3f2fd';
  ctx.fillRect(0,0,LOGICAL_W,FIELD_H);

  // leggera texture a righe
  ctx.strokeStyle = '#c5e1f5';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let y=0;y<FIELD_H;y+=64){
    ctx.moveTo(0,y); ctx.lineTo(LOGICAL_W,y);
  }
  for(let x=0;x<LOGICAL_W;x+=80){
    ctx.moveTo(x,0); ctx.lineTo(x,FIELD_H);
  }
  ctx.stroke();

  // highlight corsia selezionata
  const laneW = LOGICAL_W / 3;
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.fillRect(selectedLane * laneW, 0, laneW, FIELD_H);

  // fiume
  const riverH = 40;
  const y0 = RIVER_Y - riverH/2;
  const grad = ctx.createLinearGradient(0,y0,0,y0+riverH);
  grad.addColorStop(0,'#b3e5fc');
  grad.addColorStop(1,'#4fc3f7');
  ctx.fillStyle = grad;
  ctx.fillRect(0,y0,LOGICAL_W,riverH);

  // ponti
  ctx.fillStyle = '#8d6e63';
  const bridgeW = 140, bridgeH = 22;
  ctx.fillRect(LOGICAL_W*0.3-bridgeW/2,RIVER_Y-bridgeH/2,bridgeW,bridgeH);
  ctx.fillRect(LOGICAL_W*0.7-bridgeW/2,RIVER_Y-bridgeH/2,bridgeW,bridgeH);
}

function drawTower(t, friendly){
  // base
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 10;
  ctx.fillStyle = '#cfd8dc';
  ctx.beginPath();
  ctx.roundRect(t.x-26,t.y-30,52,60,10);
  ctx.fill();
  ctx.restore();

  // cupola
  ctx.fillStyle = friendly ? '#42a5f5' : '#ef5350';
  ctx.beginPath();
  ctx.arc(t.x, t.y-14, 18, 0, Math.PI*2);
  ctx.fill();

  // cannone (solo decorativo)
  ctx.fillStyle = '#263238';
  ctx.fillRect(t.x-6, t.y-4, 12, 14);

  // barra HP
  const w = 70, h = 7;
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(t.x-w/2, t.y-40, w, h);
  const ratio = clamp(t.hp/t.maxHp, 0, 1);
  const g = ctx.createLinearGradient(t.x-w/2,0,t.x+w/2,0);
  g.addColorStop(0,'#81c784');
  g.addColorStop(1,'#43a047');
  ctx.fillStyle = g;
  ctx.fillRect(t.x-w/2, t.y-40, w*ratio, h);
}

function drawUnit(u){
  // ombra
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(u.x, u.y+10, 18, 6, 0, 0, Math.PI*2);
  ctx.fill();

  // corpo stile "mini soldato"
  const bodyColor = (u.team === 'player') ? '#42a5f5' : '#ffb74d';
  const accent    = (u.type === 'tank') ? '#ff7043' :
                    (u.type === 'spark') ? '#fff176' :
                    (u.type === 'healer') ? '#81c784' : bodyColor;

  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.roundRect(u.x-14, u.y-22, 28, 30, 6);
  ctx.fill();

  ctx.fillStyle = accent;
  ctx.beginPath();
  ctx.roundRect(u.x-10, u.y-18, 20, 18, 4);
  ctx.fill();

  // testa
  ctx.fillStyle = '#ffe0b2';
  ctx.beginPath();
  ctx.arc(u.x, u.y-30, 10, 0, Math.PI*2);
  ctx.fill();

  // occhi
  ctx.fillStyle = '#37474f';
  ctx.beginPath();
  ctx.arc(u.x-3, u.y-31, 1.4, 0, Math.PI*2);
  ctx.arc(u.x+3, u.y-31, 1.4, 0, Math.PI*2);
  ctx.fill();

  // barra HP
  const ratio = clamp(u.hp/u.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(u.x-12, u.y-40, 24, 5);
  const g = ctx.createLinearGradient(u.x-12,0,u.x+12,0);
  g.addColorStop(0,'#a5d6a7');
  g.addColorStop(1,'#43a047');
  ctx.fillStyle = g;
  ctx.fillRect(u.x-12, u.y-40, 24*ratio, 5);
}

function drawCrystal(){
  const c = state.manaCrystal;
  if(!c.alive) return;

  // base
  ctx.fillStyle = '#455a64';
  ctx.beginPath();
  ctx.ellipse(c.x, c.y+16, 26, 10, 0, 0, Math.PI*2);
  ctx.fill();

  // cristallo
  const g = ctx.createLinearGradient(c.x, c.y-32, c.x, c.y+32);
  g.addColorStop(0,'#e1f5fe');
  g.addColorStop(1,'#0288d1');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(c.x, c.y-32);
  ctx.lineTo(c.x+22, c.y);
  ctx.lineTo(c.x, c.y+32);
  ctx.lineTo(c.x-22, c.y);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#01579b';
  ctx.lineWidth = 2;
  ctx.stroke();

  // barra HP
  const ratio = clamp(c.hp/c.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(c.x-24, c.y-42, 48, 6);
  const g2 = ctx.createLinearGradient(c.x-24,0,c.x+24,0);
  g2.addColorStop(0,'#b3e5fc');
  g2.addColorStop(1,'#0288d1');
  ctx.fillStyle = g2;
  ctx.fillRect(c.x-24, c.y-42, 48*ratio, 6);

  ctx.fillStyle = '#e1f5fe';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Cristallo Mana', c.x, c.y-52);
}

function drawProjectiles(){
  for(const p of state.projectiles){
    // scia
    ctx.save();
    ctx.globalAlpha = 0.4;
    const gx0 = p.x - p.vx*0.05;
    const gy0 = p.y - p.vy*0.05;
    const grad = ctx.createLinearGradient(gx0,gy0,p.x,p.y);
    grad.addColorStop(0, 'rgba(255,255,255,0)');
    grad.addColorStop(1, p.colorB);
    ctx.strokeStyle = grad;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(gx0,gy0);
    ctx.lineTo(p.x,p.y);
    ctx.stroke();
    ctx.restore();

    // corpo
    const glow = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,8);
    glow.addColorStop(0,p.colorA);
    glow.addColorStop(1,'rgba(255,255,255,0)');
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(p.x,p.y,6,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

function drawTopBar(){
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0,0,LOGICAL_W,26);
  ctx.fillStyle = '#ffd54f';
  ctx.font = 'bold 13px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('üëë ' + state.crownsYou, 8, 17);
  ctx.textAlign = 'right';
  ctx.fillText(state.crownsEnemy + ' üëë', LOGICAL_W-8, 17);
}

function drawManaAndCards(){
  const barX = 16, barY = FIELD_H + 12;
  const barW = LOGICAL_W - 32, barH = 12;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(barX, barY, barW, barH);
  const ratio = state.mana / state.manaMax;
  const g = ctx.createLinearGradient(barX,0,barX+barW,0);
  g.addColorStop(0,'#64b5f6');
  g.addColorStop(1,'#1e88e5');
  ctx.fillStyle = g;
  ctx.fillRect(barX, barY, barW*ratio, barH);

  if(manaFlash > 0){
    ctx.save();
    ctx.globalAlpha = manaFlash / 0.4;
    ctx.fillStyle = 'rgba(244,67,54,0.5)';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.restore();
  }

  ctx.fillStyle = '#fff';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('Mana: ' + Math.floor(state.mana) + ' / ' + state.manaMax, barX, barY-4);

  // carte
  const cardY = FIELD_H + 32;
  const pad = 12;
  const gap = 8;
  const totalGap = gap * (CARDS.length-1);
  const cardW = (LOGICAL_W - pad*2 - totalGap) / CARDS.length;
  const cardH = UI_H - 42;

  cardRects = [];
  for(let i=0;i<CARDS.length;i++){
    const c = CARDS[i];
    const x = pad + i*(cardW+gap);
    const y = cardY;
    cardRects.push({ x, y, w:cardW, h:cardH });

    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.beginPath();
    ctx.roundRect(x, y, cardW, cardH, 10);
    ctx.fill();

    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.roundRect(x+4, y+4, cardW-8, cardH-26, 8);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(c.label, x+cardW/2, y+cardH-10);

    if(c.key !== 'reset'){
      ctx.font = 'bold 14px system-ui';
      ctx.fillText(String(c.cost), x+cardW/2, y+18);
    }else{
      ctx.font = '12px system-ui';
      ctx.fillText('‚Üª', x+cardW/2, y+18);
    }
  }

  ctx.textAlign = 'center';
  ctx.font = '11px system-ui';
  ctx.fillStyle = '#cfd8dc';
  ctx.fillText('Tocca il campo per scegliere la corsia, poi le carte.', LOGICAL_W/2, FIELD_H+UI_H-6);
}

function drawEndBanner(){
  if(!endBanner) return;
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  const w = LOGICAL_W*0.8;
  const h = 80;
  const x = (LOGICAL_W-w)/2;
  const y = FIELD_H/2 - h/2;
  ctx.beginPath();
  ctx.roundRect(x,y,w,h,12);
  ctx.fill();

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(endBanner, LOGICAL_W/2, y+32);
  ctx.font = '13px system-ui';
  ctx.fillText("Tocca 'Riavvia' per giocare ancora.", LOGICAL_W/2, y+54);
}

function render(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(scale,0,0,scale,offX,offY);

  drawBackground();
  drawTopBar();

  // torri
  for(const t of state.enemyTowers) drawTower(t,false);
  for(const t of state.playerTowers) drawTower(t,true);

  drawCrystal();

  // unit√† + proiettili
  for(const u of state.units) drawUnit(u);
  drawProjectiles();

  drawManaAndCards();
  drawEndBanner();
}

// ===================== Loop principale =====================
let lastTime = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===================== PWA: service worker =====================
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('sw.js').catch(()=>{});
}
</script>
</body>
</html>
