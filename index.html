<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arena Duel – MVP</title>
  <style>
    :root{
      --bg-dark:#0e1013;
      --ui-bg:#1b2330;
      --ui-br:#2c3c54;
      --ink:#eef;
      --good:#4ee46a;
      --bad:#ff9a3c;
      --river:#8ad1e8;
      --sand:#e7dfb5;
    }
    html, body { margin:0; height:100%; background:var(--bg-dark); color:var(--ink); font-family:system-ui, sans-serif; }
    #topbar { position:fixed; left:0; right:0; top:0; padding:8px 12px; display:flex; justify-content:space-between; align-items:center; background:#0e1013cc; backdrop-filter: blur(3px);}
    #mana { height:12px; background:#22324a; border-radius:8px; overflow:hidden; width:240px; border:1px solid #2c3c54; position:relative; }
    #mana > div { height:100%; background:#61dafb; width:0%; transition:width .12s linear; box-shadow:0 0 10px #61dafb88 inset, 0 0 12px #61dafb66; }
    #mana::after{ content:""; position:absolute; inset:0; background:linear-gradient(90deg,transparent 0%,#ffffff44 30%,transparent 60%); animation: shimmer 2.6s linear infinite; mix-blend-mode: screen; }
    @keyframes shimmer{ from{ transform:translateX(-100%);} to{ transform:translateX(100%);} }

    canvas { display:block; margin:0 auto; background:var(--sand); }

    #ui { position:fixed; left:0; right:0; bottom:0; padding:12px; display:flex; gap:10px; justify-content:center; background:linear-gradient(180deg, transparent, #0007 50%, #000c); }
    .card, button { background:var(--ui-bg); color:var(--ink); border:1px solid var(--ui-br); padding:8px 12px; border-radius:12px; cursor:pointer; user-select:none; box-shadow:0 4px 12px #00000040; }
    .card:active, button:active { transform:translateY(1px); }
    button { opacity:.9; }
  </style>
</head>
<body>
  <div id="topbar">
    <div><strong>Arena Duel (MVP)</strong></div>
    <div id="status"></div>
    <div id="mana"><div></div></div>
  </div>

  <!-- Canvas dimensioni “portrait” per telefono; si adatta in automatico -->
  <canvas id="game" width="720" height="1080"></canvas>

  <div id="ui">
    <div class="card" data-cost="3" data-type="scout">Scout (3)</div>
    <div class="card" data-cost="4" data-type="tank">Tank (4)</div>
    <div class="card" data-cost="2" data-type="spark">Spark (2)</div>
    <button id="restart">Riavvia</button>
  </div>

  <script>
  // ---------- Utils
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // ---------- Canvas / Layout
  const W = 720, H = 1080;
  const LANE_Y = [H*0.60, H*0.72, H*0.84];
  const RIVER_Y = H*0.58;
  const ctx = document.getElementById('game').getContext('2d', { alpha:false });
  const status = document.getElementById('status');
  const manaFill = document.querySelector('#mana > div');
  let last = performance.now();
  let playing = true;

  // ---------- Stato di gioco
  const state = {
    mana: 5, manaMax: 10, manaRegen: 0.015,
    playerTowers: [
      {x: W*0.12, y: H*0.65, hp: 100, max: 100},
      {x: W*0.12, y: H*0.79, hp: 100, max: 100},
    ],
    enemyTowers: [
      {x: W*0.88, y: H*0.65, hp: 100, max: 100},
      {x: W*0.88, y: H*0.79, hp: 100, max: 100},
    ],
    units: [],
    floats: [],   // numeri danno/cura
    particles: [],// scintille
    time: 0,
    t: 0
  };

  // ---------- Unità
  function addUnit(team, lane, type){
    const y = LANE_Y[lane];
    if(type==='scout'){
      state.units.push({x: team==='P'? W*0.20 : W*0.80, y, dir: team==='P'? 1:-1, spd: 0.8, hp:18, atk:3, range:14, rate:0.7, cd:0, team, type});
    } else if(type==='tank'){
      state.units.push({x: team==='P'? W*0.20 : W*0.80, y, dir: team==='P'? 1:-1, spd: 0.45, hp:60, atk:6, range:18, rate:1.2, cd:0, team, type});
    } else if(type==='spark'){
      state.units.push({x: team==='P'? W*0.20 : W*0.80, y, dir: team==='P'? 1:-1, spd: 0.7, hp:12, atk:8, range:70, rate:1.6, cd:0, team, type});
    }
  }

  // ---------- AI semplice (usa lo stesso mana per MVP)
  let aiTimer = 2.5;
  function ai(dt){
    aiTimer -= dt;
    if(aiTimer<=0 && playing){
      aiTimer = rand(1.8, 3.2);
      const affordable = [];
      const mana = Math.floor(state.mana);
      if(mana>=2) affordable.push('spark');
      if(mana>=3) affordable.push('scout');
      if(mana>=4) affordable.push('tank');
      if(affordable.length){
        const t = affordable[(Math.random()*affordable.length)|0];
        const cost = t==='tank'?4: t==='scout'?3:2;
        state.mana = Math.max(0, state.mana - cost);
        addUnit('E', (Math.random()*3)|0, t);
      }
    }
  }

  // ---------- Danni/Cure con numeri fluttuanti + particelle
  function addFloat(x,y, value, color){
    state.floats.push({x,y, v:value, color, t:0});
  }
  function addHitSparks(x,y, color){
    for(let i=0;i<8;i++){
      state.particles.push({x,y, vx:rand(-1,1), vy:rand(-1.5,-0.4), life:rand(0.3,0.6), t:0, color});
    }
  }
  function applyDamage(target, dmg){
    if(!('hp' in target)) return;
    target.hp -= dmg;
    const color = dmg>=0 ? '#ffb36a' : '#6afc86';
    addFloat(target.x, target.y-26, (dmg>=0?'-':'+')+Math.abs(dmg), color);
    addHitSparks(target.x, target.y-10, color);
  }

  // ---------- Targeting
  function nearestTarget(u, towers, foes){
    let best=null, bestD=1e9;
    for(const f of foes){
      const d = Math.hypot(f.x*u.dir - u.x*u.dir, f.y-u.y);
      if(d<bestD) {bestD=d; best=f;}
    }
    if(!best){
      let tgt=null, dmin=1e9;
      for(const t of towers){
        const d = Math.abs(t.y-u.y) + Math.abs(t.x-u.x);
        if(t.hp>0 && d<dmin){dmin=d; tgt=t;}
      }
      best=tgt; bestD = best? Math.hypot(best.x-u.x, best.y-u.y):1e9;
    }
    return {t:best, d:bestD};
  }

  // ---------- Step logico
  function step(dt){
    if(!playing) return;

    state.t += dt;
    state.time += dt;
    state.mana = clamp(state.mana + (state.manaRegen + 0.003*Math.sin(state.t*2.2))*60*dt, 0, state.manaMax);
    manaFill.style.width = (state.mana/state.manaMax*100).toFixed(1)+'%';

    ai(dt);

    for(const u of state.units){
      const enemyTeam = u.team==='P' ? 'E' : 'P';
      const foeUnits = state.units.filter(x=>x.team===enemyTeam);
      const foeTowers = (enemyTeam==='E'? state.enemyTowers: state.playerTowers);
      const {t,d} = nearestTarget(u, foeTowers, foeUnits);

      u.cd -= dt;
      if(t && d <= u.range){
        if(u.cd<=0){
          u.cd = u.rate;
          if('hp' in t) applyDamage(t, u.atk); // usa animazioni
        }
      } else {
        u.x += u.spd * u.dir * 60 * dt;
      }
    }

    // Float texts
    for(const f of state.floats){
      f.t += dt; f.y -= 20*dt; f.x += Math.sin(f.t*6)*6*dt;
    }
    state.floats = state.floats.filter(f=>f.t<0.9);

    // Particelle
    for(const p of state.particles){
      p.t += dt; p.x += p.vx*60*dt; p.y += p.vy*60*dt; p.vy += 0.03; // gravità leggera
    }
    state.particles = state.particles.filter(p=>p.t<p.life);

    // Pulizia
    state.units = state.units.filter(u=>u.hp>0 && u.x>0 && u.x<W);

    // Win/Lose
    const pAlive = state.playerTowers.some(t=>t.hp>0);
    const eAlive = state.enemyTowers.some(t=>t.hp>0);
    if(!pAlive || !eAlive){
      playing=false;
      status.textContent = !pAlive ? "Sconfitta" : "Vittoria!";
    }
  }

  // ---------- Disegno
  function drawBackground(){
    // sabbia con gradiente
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#efe7be'); g.addColorStop(1,'#dbcf9a');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // griglia molto tenue
    ctx.strokeStyle = '#00000010'; ctx.lineWidth=1;
    const step=60;
    ctx.beginPath();
    for(let x=0;x<=W;x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for(let y=0;y<=H;y+=step){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();

    // corsie
    ctx.strokeStyle = '#b9b083';
    ctx.lineWidth = 2;
    LANE_Y.forEach(y=>{ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); });

    // fiume con riflesso animato
    ctx.fillStyle = '#7ccbe1';
    ctx.fillRect(0, RIVER_Y-6, W, 12);
    const waveX = (Math.sin(state.t*1.2)*0.5+0.5)*W*0.6;
    const grad = ctx.createLinearGradient(waveX-120,0,waveX+120,0);
    grad.addColorStop(0, '#ffffff00'); grad.addColorStop(0.5,'#ffffff66'); grad.addColorStop(1,'#ffffff00');
    ctx.fillStyle = grad; ctx.fillRect(0, RIVER_Y-6, W, 12);

    // ponti
    function bridge(cx){
      ctx.save();
      ctx.translate(cx,RIVER_Y);
      ctx.fillStyle='#8c5a2c'; ctx.strokeStyle='#5e3c1c'; ctx.lineWidth=3;
      ctx.fillRect(-40,-12,80,24); ctx.strokeRect(-40,-12,80,24);
      // assi
      ctx.strokeStyle='#75471f';
      for(let i=-36;i<=36;i+=12){ ctx.beginPath(); ctx.moveTo(i,-12); ctx.lineTo(i,12); ctx.stroke(); }
      ctx.restore();
    }
    bridge(W*0.3);
    bridge(W*0.7);
  }

  function drawTower(t, friendly){
    // ombra
    ctx.fillStyle = '#00000020';
    ctx.beginPath(); ctx.ellipse(t.x, t.y+10, 26, 10, 0, 0, Math.PI*2); ctx.fill();

    // base
    ctx.fillStyle = friendly? '#4b6cb7' : '#c24b4b';
    ctx.strokeStyle = friendly? '#0e3f8f' : '#8a1f1f';
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(t.x,t.y,24,0,Math.PI*2); ctx.fill(); ctx.stroke();

    // “corona” stilizzata
    ctx.fillStyle = '#f2d16b'; ctx.strokeStyle='#a8841e';
    ctx.beginPath(); ctx.moveTo(t.x-14, t.y-20);
    ctx.lineTo(t.x-7, t.y-10); ctx.lineTo(t.x, t.y-20);
    ctx.lineTo(t.x+7, t.y-10); ctx.lineTo(t.x+14, t.y-20);
    ctx.lineTo(t.x+14, t.y-8); ctx.lineTo(t.x-14, t.y-8); ctx.closePath();
    ctx.fill(); ctx.stroke();

    // HP bar
    const w=70, h=8;
    ctx.fillStyle = '#00000055'; ctx.fillRect(t.x-w/2, t.y-34, w, h);
    const p = clamp(t.hp/t.max,0,1);
    ctx.fillStyle = '#4ee46a';
    ctx.fillRect(t.x-w/2, t.y-34, w*p, h);
    ctx.strokeStyle='#183b1f66'; ctx.strokeRect(t.x-w/2, t.y-34, w, h);
  }

  function drawUnit(u){
    // ombra
    ctx.fillStyle = '#00000020';
    ctx.beginPath(); ctx.ellipse(u.x, u.y+8, 16, 7, 0, 0, Math.PI*2); ctx.fill();

    // corpo
    if(u.team==='P'){ ctx.fillStyle = '#2f80ed'; ctx.strokeStyle='#0b4ea2'; }
    else { ctx.fillStyle = '#eb5757'; ctx.strokeStyle='#9b1c1c'; }
    ctx.lineWidth=2;

    if(u.type==='tank'){
      ctx.fillRect(u.x-16, u.y-12, 32, 24); ctx.strokeRect(u.x-16, u.y-12, 32, 24);
    } else if(u.type==='scout'){
      ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke();
    } else { // spark = triangolo
      ctx.beginPath(); ctx.moveTo(u.x-14,u.y+10); ctx.lineTo(u.x+14,u.y+10); ctx.lineTo(u.x,u.y-12); ctx.closePath(); ctx.fill(); ctx.stroke();
    }

    // HP mini
    ctx.fillStyle='#00000055'; ctx.fillRect(u.x-12, u.y-20, 24, 4);
    const maxhp = u.type==='tank'?60:u.type==='scout'?18:12;
    ctx.fillStyle='#4ee46a'; ctx.fillRect(u.x-12, u.y-20, 24*clamp(u.hp/maxhp,0,1),4);
  }

  function draw(){
    drawBackground();

    // Torri
    state.playerTowers.forEach(t=>drawTower(t,true));
    state.enemyTowers.forEach(t=>drawTower(t,false));

    // Unità
    for(const u of state.units){ drawUnit(u); }

    // Numeri fluttuanti
    for(const f of state.floats){
      const a = 1 - f.t/0.9;
      ctx.globalAlpha = a;
      ctx.fillStyle = f.color;
      ctx.font = 'bold 16px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(f.v, f.x, f.y);
      ctx.globalAlpha = 1;
    }

    // Particelle
    for(const p of state.particles){
      const a = 1 - p.t/p.life;
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x-2, p.y-2, 4, 4);
      ctx.globalAlpha = 1;
    }
  }

  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000);
    last=t; step(dt); draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Input
  document.querySelectorAll('.card').forEach(card=>{
    card.addEventListener('click', ()=>{
      const cost = +card.dataset.cost;
      const type = card.dataset.type;
      if(state.mana < cost || !playing) return;
      const lane = Math.floor(state.time*2) % 3;
      addUnit('P', lane, type);
      state.mana = Math.max(0, state.mana - cost);
    });
  });

  document.getElementById('restart').onclick = ()=>{
    state.mana=5; state.units.length=0; state.time=0; state.t=0; playing=true; status.textContent='';
    state.playerTowers.forEach(t=>{t.hp=t.max;});
    state.enemyTowers.forEach(t=>{t.hp=t.max;});
  };

  // ---------- Logica di combattimento (dopo input) ----------
  function combatStep(u, dt){
    const enemyTeam = u.team==='P' ? 'E' : 'P';
    const foeUnits = state.units.filter(x=>x.team===enemyTeam);
    const foeTowers = (enemyTeam==='E'? state.enemyTowers: state.playerTowers);
    const {t,d} = nearestTarget(u, foeTowers, foeUnits);

    u.cd -= dt;
    if(t && d <= u.range){
      if(u.cd<=0){
        u.cd = u.rate;
        if('hp' in t) applyDamage(t, u.atk);
      }
    } else {
      u.x += u.spd * u.dir * 60 * dt;
    }
  }

  // rimpiazza loop di movimento con combatStep dentro step (già fatto sopra)
  </script>
</body>
</html>
