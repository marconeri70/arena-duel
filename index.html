<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Arena Duel ‚Äì Vertical</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#020617" />
  <link rel="manifest" href="manifest.webmanifest" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// ======================= Canvas & mapping (portrait) =========================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

const W = 720;
const H = 1280;
const TOP_UI = 40;
const BOTTOM_UI = 190;
const FIELD_H = H - TOP_UI - BOTTOM_UI;

let scale = 1;
let offX = 0;
let offY = 0;

function resize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.max(1, Math.round(rect.width  * dpr));
  canvas.height = Math.max(1, Math.round(rect.height * dpr));
  scale = Math.min(canvas.width / W, canvas.height / H);
  offX  = Math.floor((canvas.width  - W * scale) / 2);
  offY  = Math.floor((canvas.height - H * scale) / 2);
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);
resize();

function toLogical(ev) {
  const rect = canvas.getBoundingClientRect();
  const X = (ev.clientX - rect.left) * (canvas.width  / rect.width);
  const Y = (ev.clientY - rect.top ) * (canvas.height / rect.height);
  return {
    x: (X - offX) / scale,
    y: (Y - offY) / scale
  };
}

// ============================ Helpers ========================================
const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
const rand   = (a, b) => a + Math.random() * (b - a);

// click-targets per menu, carte, ecc.
let hitZones = [];
function clearHitZones() { hitZones = []; }
function addHitZone(x, y, w, h, onClick) {
  hitZones.push({ x, y, w, h, onClick });
}
canvas.addEventListener('pointerdown', ev => {
  const p = toLogical(ev);
  for (const z of hitZones) {
    if (p.x >= z.x && p.x <= z.x + z.w &&
        p.y >= z.y && p.y <= z.y + z.h) {
      z.onClick();
      return;
    }
  }
  // se nessun bottone intercettato, gestisco lo schermo di gioco
  if (screen === 'play') handlePlayTap(p.x, p.y);
});

function softShadow(x, y, rx, ry, alpha = 0.22) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ====================== Profilo & progressi (localStorage) ===================
let profile = loadProfile();

function loadProfile() {
  try {
    const raw = localStorage.getItem('arenaDuelProfile_v1');
    if (raw) return JSON.parse(raw);
  } catch (e) {}
  return {
    wins: 0,
    losses: 0,
    draws: 0,
    arenaId: 'meadow',
    deck: ['scout', 'spark', 'tank', 'healer'] // 4 carte base
  };
}
function saveProfile() {
  try {
    localStorage.setItem('arenaDuelProfile_v1', JSON.stringify(profile));
  } catch (e) {}
}

// ============================== Arene ========================================

const LANES_X = [W * 0.2, W * 0.5, W * 0.8];

const ARENAS = [
  {
    id: 'meadow',
    name: 'Prato Tranquillo',
    difficulty: 1,
    bgTop: '#1f2933',
    grassLight: '#d7f3c8',
    grassDark: '#b7d79f'
  },
  {
    id: 'desert',
    name: 'Dune del Sole',
    difficulty: 2,
    bgTop: '#251f1b',
    grassLight: '#f3e0b6',
    grassDark: '#ddb771'
  },
  {
    id: 'volcano',
    name: 'Valle della Lava',
    difficulty: 3,
    bgTop: '#1b1020',
    grassLight: '#f1d0c5',
    grassDark: '#d19788'
  }
];
function currentArena() {
  return ARENAS.find(a => a.id === profile.arenaId) || ARENAS[0];
}

// ============================== Carte ========================================

const CARD_DATA = [
  {
    id: 'scout',
    name: 'Scout',
    desc: 'Fan¬≠teria veloce corpo a corpo.',
    cost: 3,
    unlockWins: 0,
    color: '#60a5fa',
    type: 'melee',
    hp: 22,
    atk: 4,
    spd: 1.2,
    range: 26
  },
  {
    id: 'spark',
    name: 'Spark',
    desc: 'Unit√† a distanza rapida.',
    cost: 2,
    unlockWins: 0,
    color: '#fbbf24',
    type: 'ranged',
    hp: 16,
    atk: 5,
    spd: 1.0,
    range: 120
  },
  {
    id: 'tank',
    name: 'Tank',
    desc: 'Pesante, tanta vita.',
    cost: 4,
    unlockWins: 2,
    color: '#fb7185',
    type: 'melee',
    hp: 60,
    atk: 6,
    spd: 0.7,
    range: 30
  },
  {
    id: 'healer',
    name: 'Healer',
    desc: 'Support, cura alleati.',
    cost: 3,
    unlockWins: 4,
    color: '#34d399',
    type: 'healer',
    hp: 20,
    atk: -6,
    spd: 1.0,
    range: 100
  }
  // in futuro puoi aggiungere altre carte qui
];

function unlockedCards() {
  return CARD_DATA.filter(c => profile.wins >= c.unlockWins);
}

function cardById(id) {
  return CARD_DATA.find(c => c.id === id);
}

// ============================= Audio SFX =====================================
let AC = null;
function sfx(kind) {
  try {
    AC = AC || new (window.AudioContext || window.webkitAudioContext)();
    const osc = AC.createOscillator();
    const gain = AC.createGain();
    const table = {
      hit:   [220, 0.06, 'square'],
      place: [660, 0.07, 'square'],
      win:   [880, 0.4,  'triangle'],
      lose:  [160, 0.4,  'triangle'],
      mana:  [520, 0.15, 'sine']
    };
    const [f, t, type] = table[kind] || [440, 0.08, 'square'];
    osc.type = type;
    osc.frequency.value = f;
    gain.gain.value = 0.06;
    osc.connect(gain);
    gain.connect(AC.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.0001, AC.currentTime + t);
    osc.stop(AC.currentTime + t);
  } catch (e) {}
}

// ========================== Stato partita ====================================

let screen = 'menu'; // 'menu' | 'play' | 'cards' | 'arenas'

let battle = null;

function newBattle() {
  const arena = currentArena();
  const baseManaMax = 10 + (arena.difficulty - 1) * 2;

  battle = {
    arenaId: arena.id,
    time: 0,
    playing: true,
    resultShown: false,
    selectedLane: 1,
    manaP: 5,
    manaE: 5,
    manaMaxP: baseManaMax,
    manaMaxE: baseManaMax,
    manaRegen: 0.016, // per tick
    units: [],
    projectiles: [],
    floats: [],
    particles: [],
    playerTowers: [
      { team: 'P', x: LANES_X[0], y: TOP_UI + FIELD_H - 70, hp: 120, maxHp: 120 },
      { team: 'P', x: LANES_X[2], y: TOP_UI + FIELD_H - 70, hp: 120, maxHp: 120 }
    ],
    enemyTowers: [
      { team: 'E', x: LANES_X[0], y: TOP_UI + 70, hp: 120, maxHp: 120 },
      { team: 'E', x: LANES_X[2], y: TOP_UI + 70, hp: 120, maxHp: 120 }
    ],
    crystal: {
      x: W * 0.5,
      y: TOP_UI + FIELD_H * 0.5,
      hp: 80,
      maxHp: 80,
      alive: true,
      owner: null, // 'P' o 'E'
      bonusShown: false
    },
    crowns: { you: 0, enemy: 0 },
    message: ''
  };
}

function laneBounds(idx) {
  const full = W / 3;
  return {
    x: idx * full,
    w: full
  };
}

function addFloat(text, x, y, color) {
  battle.floats.push({ text, x, y, color, t: 0 });
}

function addParticles(x, y, color) {
  for (let i = 0; i < 10; i++) {
    battle.particles.push({
      x, y,
      vx: rand(-1, 1),
      vy: rand(-1.5, -0.4),
      life: rand(0.3, 0.6),
      t: 0,
      color
    });
  }
}

function damage(target, amount) {
  if (!target || target.hp == null) return;
  target.hp -= amount;
  const txt = '-' + amount;
  addFloat(txt, target.x, target.y - 24, '#fecaca');
  addParticles(target.x, target.y - 10, '#f97373');
  sfx('hit');
}

function heal(target, amount) {
  if (!target || target.hp == null) return;
  const before = target.hp;
  target.hp = Math.min(target.maxHp, target.hp + amount);
  const diff = Math.round(target.hp - before);
  if (diff > 0) {
    addFloat('+' + diff, target.x, target.y - 24, '#bbf7d0');
  }
}

// =========================== Unit√† & proiettili ==============================

function spawnUnit(team, laneIndex, cardId) {
  const card = cardById(cardId);
  if (!card) return;

  const isPlayer = team === 'P';
  const laneX = LANES_X[laneIndex];
  const startY = isPlayer ? (TOP_UI + FIELD_H - 110) : (TOP_UI + 110);
  const dir = isPlayer ? -1 : 1;

  const u = {
    team,
    lane: laneIndex,
    x: laneX,
    y: startY,
    dir,
    type: card.type,
    color: card.color,
    hp: card.hp,
    maxHp: card.hp,
    atk: Math.abs(card.atk),
    heal: card.type === 'healer',
    spd: card.spd,
    range: card.range,
    rate: 1.0,
    cd: 0
  };
  battle.units.push(u);
  addParticles(u.x, u.y, isPlayer ? '#60a5fa' : '#fb7185');
  sfx('place');
}

function fireProjectile(from, target, opts) {
  const dx = target.x - from.x;
  const dy = target.y - from.y;
  const L = Math.hypot(dx, dy) || 1;
  const speed = opts.speed || 520;
  const vx = (dx / L) * speed;
  const vy = (dy / L) * speed;

  battle.projectiles.push({
    x: from.x,
    y: from.y,
    vx,
    vy,
    team: opts.team,
    heal: !!opts.heal,
    dmg: opts.dmg || 5,
    life: 1.5,
    colorA: opts.colorA || '#fff',
    colorB: opts.colorB || '#0af'
  });
}

function nearestEnemyAhead(u) {
  const enemyTeam = u.team === 'P' ? 'E' : 'P';
  let best = null;
  let bestScore = 99999;

  // unit√†
  for (const v of battle.units) {
    if (v.team !== enemyTeam || v.lane !== u.lane) continue;
    const dy = (v.y - u.y) * u.dir;
    if (dy <= 0) continue; // deve essere davanti
    const score = dy;
    if (score < bestScore) {
      bestScore = score;
      best = v;
    }
  }
  // torri
  const towers = enemyTeam === 'P' ? battle.playerTowers : battle.enemyTowers;
  for (const t of towers) {
    const dy = (t.y - u.y) * u.dir;
    if (dy <= 0) continue;
    const dx = Math.abs(t.x - u.x);
    const score = dy + dx * 0.25;
    if (score < bestScore) {
      bestScore = score;
      best = t;
    }
  }
  // cristallo (solo corsia centrale)
  if (battle.crystal.alive && u.lane === 1) {
    const c = battle.crystal;
    const dy = (c.y - u.y) * u.dir;
    if (dy > 0) {
      const score = dy;
      if (score < bestScore) {
        bestScore = score;
        best = c;
      }
    }
  }

  const dist = best ? Math.hypot(best.x - u.x, best.y - u.y) : 99999;
  return { target: best, dist };
}

function nearestAllyAhead(u) {
  let best = null;
  let bestDy = 99999;
  for (const v of battle.units) {
    if (v === u || v.team !== u.team || v.lane !== u.lane) continue;
    const dy = (v.y - u.y) * u.dir;
    if (dy <= 0) continue; // deve essere davanti
    if (dy < bestDy) {
      bestDy = dy;
      best = v;
    }
  }
  return { ally: best, dist: bestDy };
}

// IA semplice per l'avversario
let aiTimer = 2.0;
function aiTick(dt) {
  aiTimer -= dt;
  if (!battle.playing) return;
  if (aiTimer > 0) return;

  const arena = currentArena();
  const diff = arena.difficulty;
  aiTimer = rand(1.4, 2.4) - diff * 0.3;

  const mana = battle.manaE;
  const possible = CARD_DATA.filter(c => mana >= c.cost && profile.wins >= c.unlockWins);
  if (!possible.length) return;
  const card = possible[(Math.random() * possible.length) | 0];

  battle.manaE = Math.max(0, battle.manaE - card.cost);
  const lane = (Math.random() * 3) | 0;
  spawnUnit('E', lane, card.id);
}

// ========================= Update della partita ==============================

function updateBattle(dt) {
  if (!battle) return;
  if (battle.playing) {
    battle.time += dt;
    const arena = currentArena();

    // mana
    const regen = battle.manaRegen * (1 + (arena.difficulty - 1) * 0.3);
    battle.manaP = clamp(battle.manaP + regen * 60 * dt, 0, battle.manaMaxP);
    battle.manaE = clamp(battle.manaE + regen * 60 * dt, 0, battle.manaMaxE);

    // IA
    aiTick(dt);
  }

  // unit√†
  const minGap = 55;

  for (const u of battle.units) {
    u.cd -= dt;

    const { target, dist } = nearestEnemyAhead(u);

    // Healer: cura alleati o torri
    if (u.type === 'healer') {
      // trova alleato pi√π danneggiato in raggio
      let best = null;
      let bestGap = 0;

      for (const v of battle.units) {
        if (v.team !== u.team || v.hp >= v.maxHp) continue;
        if (v.lane !== u.lane) continue;
        const d = Math.hypot(v.x - u.x, v.y - u.y);
        const gap = v.maxHp - v.hp;
        if (d <= u.range && gap > bestGap) {
          bestGap = gap;
          best = v;
        }
      }
      const towers = u.team === 'P' ? battle.playerTowers : battle.enemyTowers;
      for (const t of towers) {
        if (t.hp >= t.maxHp) continue;
        const d = Math.hypot(t.x - u.x, t.y - u.y);
        const gap = t.maxHp - t.hp;
        if (d <= u.range && gap > bestGap) {
          bestGap = gap;
          best = t;
        }
      }

      if (best && u.cd <= 0 && battle.playing) {
        u.cd = u.rate;
        fireProjectile(u, best, {
          team: u.team,
          heal: true,
          dmg: u.atk,
          speed: 380,
          colorA: '#bbf7d0',
          colorB: '#4ade80'
        });
      } else if (battle.playing) {
        // movimento con "fila" (no sorpasso)
        const { ally, dist: dAlly } = nearestAllyAhead(u);
        let canMove = true;
        if (ally && dAlly < minGap) canMove = false;

        if (canMove) {
          u.y += u.spd * u.dir * 60 * dt;
        }
      }

      continue;
    }

    // ranged
    if (u.type === 'ranged') {
      if (target && dist <= u.range && battle.playing) {
        if (u.cd <= 0) {
          u.cd = u.rate;
          fireProjectile(u, target, {
            team: u.team,
            heal: false,
            dmg: u.atk,
            speed: 520,
            colorA: '#e5f0ff',
            colorB: u.team === 'P' ? '#60a5fa' : '#fb7185'
          });
        }
      } else if (battle.playing) {
        const { ally, dist: dAlly } = nearestAllyAhead(u);
        let canMove = true;
        if (ally && dAlly < minGap) canMove = false;
        if (canMove) {
          u.y += u.spd * u.dir * 60 * dt;
        }
      }
      continue;
    }

    // melee
    if (target && dist <= u.range && battle.playing) {
      if (u.cd <= 0) {
        u.cd = u.rate;
        damage(target, u.atk);
      }
    } else if (battle.playing) {
      const { ally, dist: dAlly } = nearestAllyAhead(u);
      let canMove = true;
      if (ally && dAlly < minGap) canMove = false;
      if (canMove) {
        u.y += u.spd * u.dir * 60 * dt;
      }
    }
  }

  // proiettili
  for (const p of battle.projectiles) {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    if (p.life <= 0) continue;

    const enemyTeam = p.heal ? p.team : (p.team === 'P' ? 'E' : 'P');
    const isHeal = p.heal;

    // unit√†
    let hit = null;
    for (const u of battle.units) {
      const good = isHeal ? (u.team === p.team) : (u.team === enemyTeam);
      if (!good) continue;
      const d = Math.hypot(u.x - p.x, u.y - p.y);
      if (d < 18) { hit = u; break; }
    }

    // torri
    if (!hit) {
      const towers = isHeal
        ? (p.team === 'P' ? battle.playerTowers : battle.enemyTowers)
        : (p.team === 'P' ? battle.enemyTowers : battle.playerTowers);
      for (const t of towers) {
        const d = Math.hypot(t.x - p.x, t.y - p.y);
        if (d < 26) { hit = t; break; }
      }
    }

    // cristallo
    if (!hit && battle.crystal.alive) {
      const d = Math.hypot(battle.crystal.x - p.x, battle.crystal.y - p.y);
      if (d < 30) hit = battle.crystal;
    }

    if (hit) {
      if (isHeal) heal(hit, p.dmg);
      else damage(hit, p.dmg);
      p.life = 0;

      // bonus cristallo
      if (hit === battle.crystal && hit.hp <= 0 && hit.alive) {
        hit.alive = false;
        hit.owner = p.team;
        battle.message = (p.team === 'P'
          ? 'Hai distrutto il Cristallo del Mana! Mana massimo +3.'
          : 'Il nemico ha distrutto il Cristallo del Mana!');
        addFloat('MANA +3', hit.x, hit.y - 40, '#bfdbfe');
        sfx('mana');
        if (p.team === 'P') battle.manaMaxP += 3;
        else battle.manaMaxE += 3;
      }
    }
  }
  battle.projectiles = battle.projectiles.filter(p =>
    p.life > 0 &&
    p.x > -40 && p.x < W + 40 &&
    p.y > TOP_UI - 40 && p.y < TOP_UI + FIELD_H + 40
  );

  // floats & particelle
  for (const f of battle.floats) {
    f.t += dt;
    f.y -= 25 * dt;
  }
  battle.floats = battle.floats.filter(f => f.t < 1.0);

  for (const p of battle.particles) {
    p.t += dt;
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vy += 0.08;
  }
  battle.particles = battle.particles.filter(p => p.t < p.life);

  // pulizia unit√† fuori campo o morte
  battle.units = battle.units.filter(u =>
    u.hp > 0 &&
    u.y > TOP_UI + 20 &&
    u.y < TOP_UI + FIELD_H - 20
  );

  // esito: corone
  const pAlive = battle.playerTowers.filter(t => t.hp > 0).length;
  const eAlive = battle.enemyTowers.filter(t => t.hp > 0).length;
  battle.crowns.you = 2 - eAlive;
  battle.crowns.enemy = 2 - pAlive;

  if (battle.playing && (pAlive === 0 || eAlive === 0)) {
    battle.playing = false;
    if (eAlive === 0 && pAlive > 0) {
      profile.wins++;
      battle.message = 'Vittoria!';
      sfx('win');
    } else if (pAlive === 0 && eAlive > 0) {
      profile.losses++;
      battle.message = 'Sconfitta!';
      sfx('lose');
    } else {
      profile.draws++;
      battle.message = 'Pareggio';
    }
    saveProfile();
  }
}

// ============================= Input partita =================================

function handlePlayTap(x, y) {
  if (!battle) return;
  if (y >= TOP_UI && y <= TOP_UI + FIELD_H) {
    // tap sul campo ‚Üí cambio corsia
    const laneW = W / 3;
    const lane = Math.floor(x / laneW);
    battle.selectedLane = clamp(lane, 0, 2);
    return;
  }

  // tap sulle carte
  if (y >= H - BOTTOM_UI && y <= H) {
    // mappo sui rect delle carte
    const deck = profile.deck
      .map(id => cardById(id))
      .filter(Boolean)
      .slice(0, 4);

    const totalW = W - 40;
    const cardW = totalW / deck.length;
    const startX = 20;

    for (let i = 0; i < deck.length; i++) {
      const cx = startX + i * cardW;
      const cy = H - BOTTOM_UI + 50;
      if (x >= cx && x <= cx + cardW && y >= cy - 10 && y <= cy + 110) {
        playCard(deck[i]);
        return;
      }
    }

    // pulsante Riavvia
    const btnW = 120;
    const bx = W / 2 - btnW / 2;
    const by = H - 70;
    if (x >= bx && x <= bx + btnW && y >= by - 24 && y <= by + 24) {
      newBattle();
    }
  }
}

function playCard(card) {
  if (!battle.playing) return;
  if (battle.manaP < card.cost) {
    addFloat('Mana insufficiente', W / 2, H - BOTTOM_UI - 10, '#fecaca');
    return;
  }
  battle.manaP -= card.cost;
  spawnUnit('P', battle.selectedLane, card.id);
}

// =========================== Rendering =======================================

function drawBackground() {
  const arena = currentArena();

  // sfondo scuro
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, arena.bgTop);
  bg.addColorStop(1, '#020617');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // prato / terreno
  const g = ctx.createLinearGradient(0, TOP_UI, 0, TOP_UI + FIELD_H);
  g.addColorStop(0, arena.grassLight);
  g.addColorStop(1, arena.grassDark);
  ctx.fillStyle = g;
  ctx.fillRect(0, TOP_UI, W, FIELD_H);

  // texture leggera
  ctx.strokeStyle = 'rgba(0,0,0,0.05)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let y = TOP_UI; y <= TOP_UI + FIELD_H; y += 64) {
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
  }
  for (let x = 0; x <= W; x += 80) {
    ctx.moveTo(x, TOP_UI);
    ctx.lineTo(x, TOP_UI + FIELD_H);
  }
  ctx.stroke();

  // corsie
  ctx.fillStyle = 'rgba(148,163,184,0.18)';
  const laneW = W / 3;
  ctx.fillRect(laneW * battle.selectedLane, TOP_UI, laneW, FIELD_H);

  // fiume
  const riverY = TOP_UI + FIELD_H * 0.5;
  const h = 36;
  const water = ctx.createLinearGradient(0, riverY - h / 2, 0, riverY + h / 2);
  water.addColorStop(0, '#bfdbfe');
  water.addColorStop(1, '#60a5fa');
  ctx.fillStyle = water;
  ctx.fillRect(0, riverY - h / 2, W, h);

  // bordi fiume
  ctx.fillStyle = '#b45309';
  ctx.fillRect(0, riverY - h / 2 - 10, W, 8);
  ctx.fillRect(0, riverY + h / 2 + 2, W, 8);

  // ponti
  const bridge = x => {
    softShadow(x, riverY + 10, 70, 12, 0.3);
    ctx.save();
    ctx.translate(x, riverY);
    const b = ctx.createLinearGradient(0, -18, 0, 18);
    b.addColorStop(0, '#facc15');
    b.addColorStop(1, '#b45309');
    ctx.fillStyle = b;
    ctx.fillRect(-70, -18, 140, 36);
    ctx.strokeStyle = '#78350f';
    ctx.lineWidth = 3;
    ctx.strokeRect(-70, -18, 140, 36);
    ctx.restore();
  };
  bridge(W * 0.3);
  bridge(W * 0.7);
}

function drawTower(t, friendly) {
  softShadow(t.x, t.y + 16, 30, 12, 0.28);

  // base cilindro
  const body = ctx.createLinearGradient(t.x, t.y - 26, t.x, t.y + 26);
  body.addColorStop(0, '#e5e7eb');
  body.addColorStop(1, '#9ca3af');
  ctx.fillStyle = body;
  ctx.beginPath();
  ctx.ellipse(t.x, t.y, 26, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#4b5563';
  ctx.lineWidth = 3;
  ctx.stroke();

  // "cannone"
  ctx.fillStyle = friendly ? '#60a5fa' : '#fb7185';
  ctx.beginPath();
  ctx.arc(t.x, t.y - 6, 16, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1f2933';
  ctx.stroke();

  // barra vita
  const w = 80;
  const h = 8;
  const ratio = clamp(t.hp / t.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(t.x - w / 2, t.y - 42, w, h);
  const bar = ctx.createLinearGradient(t.x - w / 2, 0, t.x + w / 2, 0);
  bar.addColorStop(0, '#22c55e');
  bar.addColorStop(1, '#16a34a');
  ctx.fillStyle = bar;
  ctx.fillRect(t.x - w / 2, t.y - 42, w * ratio, h);
}

function drawUnit(u) {
  softShadow(u.x, u.y + 10, 18, 8, 0.26);

  // corpo
  ctx.fillStyle = u.color;
  ctx.fillRect(u.x - 14, u.y - 18, 28, 26);

  // testa
  ctx.fillStyle = '#fed7aa';
  ctx.beginPath();
  ctx.arc(u.x, u.y - 24, 10, 0, Math.PI * 2);
  ctx.fill();

  // viso semplice
  ctx.fillStyle = '#1f2933';
  ctx.beginPath();
  ctx.arc(u.x - 4, u.y - 26, 1.3, 0, Math.PI * 2);
  ctx.arc(u.x + 4, u.y - 26, 1.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillRect(u.x - 4, u.y - 21, 8, 1.5);

  // simbolo classe
  ctx.fillStyle = 'rgba(15,23,42,0.7)';
  if (u.type === 'melee') {
    ctx.fillRect(u.x - 6, u.y - 10, 12, 10);
  } else if (u.type === 'ranged') {
    ctx.beginPath();
    ctx.moveTo(u.x, u.y - 10);
    ctx.lineTo(u.x + 7, u.y);
    ctx.lineTo(u.x - 7, u.y);
    ctx.closePath();
    ctx.fill();
  } else if (u.type === 'healer') {
    ctx.fillRect(u.x - 2, u.y - 11, 4, 12);
    ctx.fillRect(u.x - 7, u.y - 6, 14, 4);
  }

  // barra HP
  const ratio = clamp(u.hp / u.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(u.x - 14, u.y - 32, 28, 4);
  ctx.fillStyle = '#22c55e';
  ctx.fillRect(u.x - 14, u.y - 32, 28 * ratio, 4);
}

function drawCrystal() {
  const c = battle.crystal;
  if (!c.alive && c.hp <= 0 && !c.broken) {
    c.broken = true;
  }
  // base
  softShadow(c.x, c.y + 18, 30, 12, 0.28);
  ctx.fillStyle = '#111827';
  ctx.beginPath();
  ctx.ellipse(c.x, c.y + 6, 26, 12, 0, 0, Math.PI * 2);
  ctx.fill();

  // cristallo
  const g = ctx.createLinearGradient(c.x, c.y - 30, c.x, c.y + 30);
  g.addColorStop(0, '#e0f2fe');
  g.addColorStop(1, '#60a5fa');
  ctx.save();
  ctx.translate(c.x, c.y);
  ctx.beginPath();
  ctx.moveTo(0, -30);
  ctx.lineTo(24, 0);
  ctx.lineTo(0, 30);
  ctx.lineTo(-24, 0);
  ctx.closePath();
  ctx.fillStyle = g;
  ctx.fill();
  ctx.strokeStyle = '#1d4ed8';
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.restore();

  // barra HP
  const ratio = clamp(c.hp / c.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(c.x - 30, c.y - 40, 60, 5);
  ctx.fillStyle = '#38bdf8';
  ctx.fillRect(c.x - 30, c.y - 40, 60 * ratio, 5);

  ctx.fillStyle = 'rgba(15,23,42,0.8)';
  ctx.font = '12px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Cristallo del Mana', c.x, c.y - 46);
}

function drawProjectiles() {
  for (const p of battle.projectiles) {
    const trail = ctx.createLinearGradient(
      p.x - p.vx * 0.03, p.y - p.vy * 0.03,
      p.x, p.y
    );
    trail.addColorStop(0, 'rgba(0,0,0,0)');
    trail.addColorStop(1, p.colorB);
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = trail;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(p.x - p.vx * 0.03, p.y - p.vy * 0.03);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    ctx.restore();

    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 8);
    glow.addColorStop(0, p.colorA);
    glow.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawFloatsAndParticles() {
  ctx.font = '12px system-ui';
  ctx.textAlign = 'center';
  for (const f of battle.floats) {
    const a = 1 - f.t;
    ctx.fillStyle = `rgba(15,23,42,${a})`;
    ctx.fillText(f.text, f.x, f.y);
  }

  for (const p of battle.particles) {
    const a = 1 - p.t / p.life;
    ctx.fillStyle = p.color;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawTopBar() {
  ctx.fillStyle = 'rgba(15,23,42,0.85)';
  ctx.fillRect(0, 0, W, TOP_UI);

  ctx.font = '14px system-ui';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#e5e7eb';
  ctx.fillText(
    `In partita: tocca il campo per scegliere corsia, poi le carte. Vittorie: ${profile.wins}`,
    10, 26
  );

  // corone
  ctx.textAlign = 'left';
  ctx.fillText('üëë ' + battle.crowns.you, 10, 14);
  ctx.textAlign = 'right';
  ctx.fillText(battle.crowns.enemy + ' üëë', W - 10, 14);
}

function drawBottomUI() {
  const startY = H - BOTTOM_UI;

  ctx.fillStyle = 'rgba(15,23,42,0.95)';
  ctx.fillRect(0, startY, W, BOTTOM_UI);

  // barra mana
  const manaY = startY + 24;
  ctx.fillStyle = '#020617';
  ctx.fillRect(16, manaY - 8, W - 32, 10);
  const r = battle.manaP / battle.manaMaxP;
  const g = ctx.createLinearGradient(16, 0, W - 16, 0);
  g.addColorStop(0, '#38bdf8');
  g.addColorStop(1, '#3b82f6');
  ctx.fillStyle = g;
  ctx.fillRect(16, manaY - 8, (W - 32) * clamp(r, 0, 1), 10);
  ctx.fillStyle = '#e5e7eb';
  ctx.font = '12px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText(
    `Mana: ${battle.manaP.toFixed(1)} / ${battle.manaMaxP}`,
    16, manaY - 12
  );

  // carte del mazzo attivo
  const deckIds = profile.deck.filter(id => cardById(id)).slice(0, 4);
  const cards = deckIds.map(id => cardById(id));
  const totalW = W - 40;
  const cardW = totalW / cards.length;
  const baseX = 20;
  const cardY = startY + 40;

  ctx.textAlign = 'center';

  for (let i = 0; i < cards.length; i++) {
    const c = cards[i];
    const x = baseX + i * cardW;
    const w = cardW - 6;

    // corpo carta
    ctx.fillStyle = 'rgba(15,23,42,0.9)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(x, cardY, w, 90, 10);
    ctx.fill();
    ctx.stroke();

    // icona unit√†
    ctx.fillStyle = c.color;
    const cx = x + w / 2;
    const cy = cardY + 30;
    ctx.beginPath();
    ctx.arc(cx, cy, 14, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#020617';
    ctx.font = '11px system-ui';
    ctx.fillText(c.name, cx, cardY + 60);

    ctx.fillStyle = '#e5e7eb';
    ctx.font = '10px system-ui';
    ctx.fillText('Costo ' + c.cost, cx, cardY + 75);

    // zona hit
    addHitZone(x, cardY, w, 90, () => playCard(c));
  }

  // pulsante Riavvia
  const btnW = 120;
  const bx = W / 2 - btnW / 2;
  const by = H - 60;
  ctx.fillStyle = '#1d4ed8';
  ctx.beginPath();
  ctx.roundRect(bx, by - 20, btnW, 40, 20);
  ctx.fill();
  ctx.fillStyle = '#e5e7eb';
  ctx.font = '14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Riavvia', W / 2, by + 5);
  addHitZone(bx, by - 20, btnW, 40, () => newBattle());
}

function drawBattle() {
  drawBackground();

  for (const t of battle.playerTowers) drawTower(t, true);
  for (const t of battle.enemyTowers) drawTower(t, false);

  if (battle.crystal.alive || battle.crystal.hp > 0) {
    drawCrystal();
  }

  for (const u of battle.units) drawUnit(u);
  drawProjectiles();
  drawFloatsAndParticles();
  drawTopBar();
  drawBottomUI();

  // messaggio finale
  if (!battle.playing && battle.message) {
    ctx.fillStyle = 'rgba(15,23,42,0.8)';
    ctx.fillRect(W / 2 - 160, TOP_UI + FIELD_H / 2 - 60, 320, 120);
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 2;
    ctx.strokeRect(W / 2 - 160, TOP_UI + FIELD_H / 2 - 60, 320, 120);

    ctx.fillStyle = '#e5e7eb';
    ctx.textAlign = 'center';
    ctx.font = '24px system-ui';
    ctx.fillText(battle.message, W / 2, TOP_UI + FIELD_H / 2 - 16);
    ctx.font = '14px system-ui';
    ctx.fillText('Tocca "Riavvia" per rigiocare o', W / 2, TOP_UI + FIELD_H / 2 + 8);
    ctx.fillText('vai al Menu in basso al centro.', W / 2, TOP_UI + FIELD_H / 2 + 28);
  }
}

// ============================= Schermata Menu ================================

function drawButton(x, y, w, h, label, subtitle, onClick) {
  ctx.fillStyle = 'rgba(15,23,42,0.9)';
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 16);
  ctx.fill();
  ctx.strokeStyle = '#4b5563';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'center';
  ctx.font = '18px system-ui';
  ctx.fillText(label, x + w / 2, y + 26);
  if (subtitle) {
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#9ca3af';
    ctx.fillText(subtitle, x + w / 2, y + 46);
  }

  addHitZone(x, y, w, h, onClick);
}

function drawMenu() {
  const arena = currentArena();

  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, arena.bgTop);
  bg.addColorStop(1, '#020617');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'center';
  ctx.font = '32px system-ui';
  ctx.fillText('Arena Duel', W / 2, 160);

  ctx.font = '14px system-ui';
  ctx.fillText(
    `Vittorie: ${profile.wins}  ‚Ä¢  Sconfitte: ${profile.losses}  ‚Ä¢  Pareggi: ${profile.draws}`,
    W / 2, 190
  );

  ctx.font = '16px system-ui';
  ctx.fillStyle = '#bfdbfe';
  ctx.fillText(`Arena selezionata: ${arena.name}`, W / 2, 220);

  drawButton(W / 2 - 150, 280, 300, 70, 'Gioca',
    'Partita veloce contro IA', () => {
      newBattle();
      screen = 'play';
    });

  drawButton(W / 2 - 150, 380, 300, 70, 'Carte',
    'Gestisci mazzo & sblocchi', () => {
      screen = 'cards';
    });

  drawButton(W / 2 - 150, 480, 300, 70, 'Arene',
    'Scegli la grafica e difficolt√†', () => {
      screen = 'arenas';
    });
}

// ========================== Schermata Carte (mazzo) ==========================

function drawCardsScreen() {
  const arena = currentArena();
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, arena.bgTop);
  bg.addColorStop(1, '#020617');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'center';
  ctx.font = '26px system-ui';
  ctx.fillText('Carte & Mazzo', W / 2, 80);
  ctx.font = '14px system-ui';
  ctx.fillText('Tocca una carta per aggiungerla/toglierla dal mazzo (max 4).', W / 2, 110);
  ctx.fillText(`Mazzo attuale: ${profile.deck.join(', ')}`, W / 2, 132);

  const cols = 2;
  const cardW = 260;
  const cardH = 140;
  const startX = (W - (cols * cardW + (cols - 1) * 20)) / 2;
  let x = startX;
  let y = 170;
  let col = 0;

  ctx.textAlign = 'left';

  for (const c of CARD_DATA) {
    const unlocked = profile.wins >= c.unlockWins;
    ctx.fillStyle = unlocked ? 'rgba(15,23,42,0.95)' : 'rgba(30,64,175,0.4)';
    ctx.beginPath();
    ctx.roundRect(x, y, cardW, cardH, 16);
    ctx.fill();
    ctx.strokeStyle = profile.deck.includes(c.id) ? '#38bdf8' : '#4b5563';
    ctx.lineWidth = 2;
    ctx.stroke();

    // icona
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.arc(x + 40, y + 40, 20, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#e5e7eb';
    ctx.font = '16px system-ui';
    ctx.fillText(c.name, x + 80, y + 32);
    ctx.font = '12px system-ui';
    ctx.fillText(`Costo: ${c.cost}`, x + 80, y + 52);
    ctx.fillText(c.desc, x + 80, y + 72);

    if (!unlocked) {
      ctx.fillStyle = '#fecaca';
      ctx.fillText(`Sblocca con ${c.unlockWins} vittorie`, x + 80, y + 92);
    } else {
      ctx.fillStyle = profile.deck.includes(c.id) ? '#bbf7d0' : '#e5e7eb';
      ctx.fillText(
        profile.deck.includes(c.id) ? 'Nel mazzo' : 'Tocca per aggiungere',
        x + 80, y + 92
      );
    }

    addHitZone(x, y, cardW, cardH, () => {
      if (!unlocked) return;
      const idx = profile.deck.indexOf(c.id);
      if (idx >= 0) {
        profile.deck.splice(idx, 1);
      } else {
        if (profile.deck.length < 4) profile.deck.push(c.id);
      }
      saveProfile();
    });

    col++;
    if (col >= cols) {
      col = 0;
      x = startX;
      y += cardH + 20;
    } else {
      x += cardW + 20;
    }
  }

  // bottone ritorno
  drawButton(W / 2 - 120, H - 100, 240, 60, 'Torna al Menu', null, () => {
    screen = 'menu';
  });
}

// ============================ Schermata Arene =================================

function drawArenasScreen() {
  const arena = currentArena();
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, arena.bgTop);
  bg.addColorStop(1, '#020617');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'center';
  ctx.font = '26px system-ui';
  ctx.fillText('Scelta Arena', W / 2, 80);
  ctx.font = '14px system-ui';
  ctx.fillText('Ogni arena cambia grafica e difficolt√†.', W / 2, 110);

  const cardW = 260;
  const cardH = 120;
  const startX = (W - cardW) / 2;
  let y = 160;

  for (const a of ARENAS) {
    const selected = a.id === profile.arenaId;
    const locked = false; // qui potresti vincolare in base alle vittorie

    ctx.fillStyle = locked ? 'rgba(55,65,81,0.6)' : 'rgba(15,23,42,0.95)';
    ctx.beginPath();
    ctx.roundRect(startX, y, cardW, cardH, 16);
    ctx.fill();
    ctx.strokeStyle = selected ? '#38bdf8' : '#4b5563';
    ctx.lineWidth = 2;
    ctx.stroke();

    // anteprima colore prato
    const g = ctx.createLinearGradient(0, 0, 0, 60);
    g.addColorStop(0, a.grassLight);
    g.addColorStop(1, a.grassDark);
    ctx.fillStyle = g;
    ctx.fillRect(startX + 10, y + 10, cardW - 20, 50);

    ctx.fillStyle = '#e5e7eb';
    ctx.font = '18px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(a.name, startX + 20, y + 85);
    ctx.font = '12px system-ui';
    ctx.fillText(`Difficolt√†: ${a.difficulty}`, startX + 20, y + 105);

    if (selected) {
      ctx.fillStyle = '#bbf7d0';
      ctx.fillText('Selezionata', startX + 140, y + 105);
    }

    addHitZone(startX, y, cardW, cardH, () => {
      if (locked) return;
      profile.arenaId = a.id;
      saveProfile();
    });

    y += cardH + 20;
  }

  drawButton(W / 2 - 120, H - 100, 240, 60, 'Torna al Menu', null, () => {
    screen = 'menu';
  });
}

// ================================ Loop =======================================

let last = performance.now();
function frame(now) {
  const dt = Math.min((now - last) / 1000, 0.033);
  last = now;

  clearHitZones();

  if (screen === 'play') {
    updateBattle(dt);
    drawBattle();
  } else if (screen === 'cards') {
    drawCardsScreen();
  } else if (screen === 'arenas') {
    drawArenasScreen();
  } else {
    drawMenu();
  }

  // mappa sul canvas reale
  ctx.setTransform(scale, 0, 0, scale, offX, offY);
  requestAnimationFrame(frame);
}
newBattle();
requestAnimationFrame(frame);

// ======================== Service worker per PWA ============================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
