<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Arena Vertical â€“ MVP</title>
<style>
  html,body{margin:0;height:100%;background:#0f1115;}
  canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block; touch-action:none; -webkit-tap-highlight-color:transparent;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ====== Canvas fullscreen + mapping logico PORTRAIT ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d',{alpha:false});

const W=720, H=1280;           // spazio logico in VERTICALE
const UI_H=180;                // barra comandi grande
const FIELD_H=H-UI_H;

let scale=1, offX=0, offY=0;
function resize(){
  const r=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  canvas.width=Math.max(1,Math.round(r.width*dpr));
  canvas.height=Math.max(1,Math.round(r.height*dpr));
  scale=Math.min(canvas.width/W, canvas.height/H);
  offX=Math.floor((canvas.width-W*scale)/2);
  offY=Math.floor((canvas.height-H*scale)/2);
}
addEventListener('resize',resize); addEventListener('orientationchange',resize); resize();

function toLogical(e){
  const r=canvas.getBoundingClientRect();
  const xDev=(e.clientX-r.left)*(canvas.width/r.width);
  const yDev=(e.clientY-r.top)*(canvas.height/r.height);
  return {x:(xDev-offX)/scale, y:(yDev-offY)/scale};
}

/* ====== Gioco verticale ====== */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

const COL_X=[W*0.18, W*0.5, W*0.82];  // 3 colonne
const RIVER_Y=FIELD_H*0.5;

const state={
  mana:5, manaMax:10, manaRegen:0.016, t:0, playing:true, time:0,
  playerTowers:[{x:W*0.25, y:FIELD_H-90, hp:100, max:100},{x:W*0.75, y:FIELD_H-90, hp:100, max:100}],
  enemyTowers: [{x:W*0.25, y:90, hp:100, max:100},{x:W*0.75, y:90, hp:100, max:100}],
  units:[/* {team:'P'|'E', x, y, dir:-1/1, col, spd,hp,atk,range,rate,cd,type} */],
  floats:[], particles:[],
};
function addUnit(team,col,type){
  const x=COL_X[col], dir=(team==='P')?-1:1;
  const y=(team==='P')? (FIELD_H-130) : 130;
  let u={team, x, y, dir, col, type, cd:0};
  if(type==='scout') Object.assign(u,{spd:1.2, hp:16, atk:3, range:20, rate:.5});
  else if(type==='tank') Object.assign(u,{spd:.7, hp:60, atk:6, range:26, rate:1.0});
  else Object.assign(u,{spd:.9, hp:12, atk:8, range:90, rate:1.4}); // spark
  state.units.push(u);
}

let aiT=2.2;
function ai(dt){
  aiT-=dt;
  if(aiT<=0 && state.playing){
    aiT=rand(1.4,2.6);
    const m=Math.floor(state.mana), pool=[];
    if(m>=2) pool.push('spark'); if(m>=3) pool.push('scout'); if(m>=4) pool.push('tank');
    if(pool.length){
      const t=pool[(Math.random()*pool.length)|0];
      const cost=t==='tank'?4:t==='scout'?3:2;
      state.mana=Math.max(0,state.mana-cost);
      addUnit('E', (Math.random()*3)|0, t);
    }
  }
}

/* ====== Utility effetti ====== */
function addFloat(x,y,v,c){ state.floats.push({x,y,v,c,t:0}); }
function addHit(x,y,c){ for(let i=0;i<8;i++) state.particles.push({x,y,vx:rand(-1,1),vy:rand(-1.2,-.2),life:rand(.25,.5),t:0,c}); }
function hit(t,d){ if(!('hp' in t))return; t.hp-=d; const c=d>=0?'#ffb36a':'#6afc86'; addFloat(t.x,t.y-24,(d>=0?'-':'+')+Math.abs(d),c); addHit(t.x,t.y-6,c); }

function nearest(u,towers,foes){
  let best=null,b=1e9;
  for(const f of foes){ const d=Math.abs(f.y*u.dir-u.y*u.dir)+Math.abs(f.x-u.x)*.3; if(d<b){b=d;best=f;} }
  if(!best){ let tg=null,dm=1e9; for(const t of towers){ const d=Math.abs(t.y-u.y)+Math.abs(t.x-u.x)*.4; if(t.hp>0 && d<dm){dm=d; tg=t;} } best=tg; }
  return {t:best, dist:best?Math.hypot(best.x-u.x, best.y-u.y):1e9};
}

/* ====== Update ====== */
let last=performance.now();
function step(dt){
  if(!state.playing) return;
  state.time+=dt; state.t+=dt;
  state.mana=clamp(state.mana + state.manaRegen*60*dt, 0, state.manaMax);
  ai(dt);

  for(const u of state.units){
    const enemy = u.team==='P' ? 'E' : 'P';
    const foes = state.units.filter(x=>x.team===enemy && x.col===u.col);
    const towers = (enemy==='E'? state.enemyTowers : state.playerTowers).filter(t=>Math.abs(t.x-u.x)<W*0.3);
    const {t, dist} = nearest(u, towers, foes);
    u.cd-=dt;
    if(t && dist<=u.range){ if(u.cd<=0){u.cd=u.rate; hit(t,u.atk);} }
    else u.y += u.spd * u.dir * 60 * dt;
  }
  state.units = state.units.filter(u=>u.hp>0 && u.y>40 && u.y<FIELD_H-40);

  for(const f of state.floats){ f.t+=dt; f.y-=24*dt; }
  state.floats = state.floats.filter(f=>f.t<.9);
  for(const p of state.particles){ p.t+=dt; p.x+=p.vx*60*dt; p.y+=p.vy*60*dt; p.vy+=.04; }
  state.particles = state.particles.filter(p=>p.t<p.life);

  const pAlive=state.playerTowers.some(t=>t.hp>0), eAlive=state.enemyTowers.some(t=>t.hp>0);
  if(!pAlive || !eAlive) state.playing=false;
}

/* ====== Disegno (pulito) ====== */
const CARDS=[
  {label:'Scout (3)', type:'scout', cost:3},
  {label:'Tank (4)',  type:'tank',  cost:4},
  {label:'Spark (2)', type:'spark', cost:2},
  {label:'Riavvia',   type:'restart', cost:0},
];
const cardRects=[];

function bg(){
  // prato sfumato
  const g=ctx.createLinearGradient(0,0,0,FIELD_H);
  g.addColorStop(0,'#efe7be'); g.addColorStop(1,'#d9cf98');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,FIELD_H);

  // griglia leggera
  ctx.strokeStyle='#00000010'; ctx.lineWidth=1; ctx.beginPath();
  for(let y=0;y<=FIELD_H;y+=70){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  for(let x=0;x<=W;x+=90){ ctx.moveTo(x,0); ctx.lineTo(x,FIELD_H); }
  ctx.stroke();

  // fiume
  ctx.fillStyle='#7bc6de'; ctx.fillRect(0,RIVER_Y-12,W,24);
  // ponti
  const bridge = cx => {
    ctx.save(); ctx.translate(cx,RIVER_Y);
    ctx.fillStyle='#8c5a2c'; ctx.strokeStyle='#5e3c1c'; ctx.lineWidth=3;
    ctx.fillRect(-60,-16,120,32); ctx.strokeRect(-60,-16,120,32);
    ctx.strokeStyle='#6d461f';
    for(let i=-54;i<=54;i+=14){ ctx.beginPath(); ctx.moveTo(i,-16); ctx.lineTo(i,16); ctx.stroke(); }
    ctx.restore();
  };
  bridge(W*0.3); bridge(W*0.7);

  // colonne corsie
  ctx.strokeStyle='#b6aa7c'; ctx.lineWidth=2;
  for(const x of COL_X){ ctx.beginPath(); ctx.moveTo(x,20); ctx.lineTo(x,FIELD_H-20); ctx.stroke(); }
}
function tower(t, friendly){
  // ombra
  ctx.fillStyle='#00000022'; ctx.beginPath(); ctx.ellipse(t.x, t.y+10, 26, 8, 0, 0, Math.PI*2); ctx.fill();
  // base
  ctx.fillStyle=friendly?'#3b7ae0':'#d14f4f'; ctx.strokeStyle=friendly?'#17409e':'#8b2222'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(t.x,t.y,24,0,Math.PI*2); ctx.fill(); ctx.stroke();
  // corona
  ctx.fillStyle='#f4cd63'; ctx.strokeStyle='#9a7b1a';
  ctx.beginPath(); ctx.moveTo(t.x-16,t.y-22); ctx.lineTo(t.x-6,t.y-8); ctx.lineTo(t.x+6,t.y-22); ctx.lineTo(t.x+16,t.y-8); ctx.lineTo(t.x+16,t.y-2); ctx.lineTo(t.x-16,t.y-2); ctx.closePath(); ctx.fill(); ctx.stroke();
  // hp
  const w=70,h=8; ctx.fillStyle='#00000055'; ctx.fillRect(t.x-w/2,t.y-34,w,h);
  ctx.fillStyle='#4ee46a'; ctx.fillRect(t.x-w/2,t.y-34, w*clamp(t.hp/t.max,0,1), h);
}
function unit(u){
  ctx.fillStyle='#00000025'; ctx.beginPath(); ctx.ellipse(u.x, u.y+8, 16, 6, 0, 0, Math.PI*2); ctx.fill();
  if(u.team==='P'){ ctx.fillStyle='#2f80ed'; ctx.strokeStyle='#0b4ea2'; }
  else { ctx.fillStyle='#eb5757'; ctx.strokeStyle='#9b1c1c'; }
  ctx.lineWidth=2;
  if(u.type==='tank'){ ctx.fillRect(u.x-16,u.y-12,32,24); ctx.strokeRect(u.x-16,u.y-12,32,24); }
  else if(u.type==='scout'){ ctx.beginPath(); ctx.arc(u.x,u.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  else { ctx.beginPath(); ctx.moveTo(u.x-14,u.y+10); ctx.lineTo(u.x+14,u.y+10); ctx.lineTo(u.x,u.y-12); ctx.closePath(); ctx.fill(); ctx.stroke(); }
  // barra hp
  const maxhp=u.type==='tank'?60:u.type==='scout'?16:12;
  ctx.fillStyle='#00000055'; ctx.fillRect(u.x-12,u.y-20,24,4);
  ctx.fillStyle='#4ee46a'; ctx.fillRect(u.x-12,u.y-20,24*clamp(u.hp/maxhp,0,1),4);
}
function ui(){
  // pannello
  ctx.fillStyle='#0f1115'; ctx.fillRect(0,FIELD_H, W, UI_H);
  // mana
  ctx.fillStyle='#202a3a'; ctx.fillRect(24, FIELD_H+16, W-48, 14);
  ctx.fillStyle='#61dafb'; ctx.fillRect(24, FIELD_H+16, (W-48)*(state.mana/state.manaMax), 14);

  // pulsanti
  cardRects.length=0;
  const gap=18, w=(W-48-gap*(CARDS.length-1))/CARDS.length, h=66, y=FIELD_H+42; let x=24;
  ctx.font='600 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const c of CARDS){
    const enabled = (c.type==='restart') || (state.mana>=c.cost && state.playing);
    ctx.fillStyle = enabled ? '#1b2330' : '#121821';
    ctx.strokeStyle='#2c3c54'; ctx.lineWidth=2;
    // pulsante con angoli morbidi
    const r=14; ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
    ctx.fill(); ctx.stroke();
    // label
    ctx.fillStyle = enabled ? '#eef' : '#8893a8';
    ctx.fillText(c.label, x+w/2, y+h/2);
    cardRects.push({x, y, w, h, ...c});
    x += w + gap;
  }
}

/* ====== Loop ====== */
function draw(){
  // letterbox esterno
  ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#0f1115'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // mapping logico
  ctx.setTransform(scale,0,0,scale,offX,offY);

  bg();
  state.playerTowers.forEach(t=>tower(t,true));
  state.enemyTowers.forEach(t=>tower(t,false));
  for(const u of state.units) unit(u);

  for(const f of state.floats){ const a=1-f.t/.9; ctx.globalAlpha=a; ctx.fillStyle=f.c; ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.fillText(f.v,f.x,f.y); ctx.globalAlpha=1; }
  for(const p of state.particles){ const a=1-p.t/p.life; ctx.globalAlpha=a; ctx.fillStyle=p.c; ctx.fillRect(p.x-2,p.y-2,4,4); ctx.globalAlpha=1; }

  ui();
}
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  step(dt); draw(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== Input robusto (pointerdown) ====== */
canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  const {x,y}=toLogical(e);
  // click pulsanti
  for(const r of cardRects){
    if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
      if(r.type==='restart'){
        state.playing=true; state.mana=5; state.units.length=0;
        state.playerTowers.forEach(t=>t.hp=t.max);
        state.enemyTowers.forEach(t=>t.hp=t.max);
        return;
      }else if(state.playing && state.mana>=r.cost){
        addUnit('P', Math.floor(state.time*2)%3, r.type);
        state.mana = Math.max(0, state.mana-r.cost);
        return;
      }
    }
  }
},{passive:false});
</script>
</body>
</html>
